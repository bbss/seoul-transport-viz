shadow$provide.module$node_modules$$luma_DOT_gl$experimental$dist$es5$gpgpu$point_in_polygon$polygon=function(global,require,module,exports){function validate(polygon){polygon=polygon&&polygon.positions||polygon;if(!Array.isArray(polygon)&&!ArrayBuffer.isView(polygon))throw Error("invalid polygon");}function isSimple(polygon){return 1<=polygon.length&&2<=polygon[0].length&&Number.isFinite(polygon[0][0])}function isNestedRingClosed(simplePolygon){var p0=simplePolygon[0];simplePolygon=simplePolygon[simplePolygon.length-
1];return p0[0]===simplePolygon[0]&&p0[1]===simplePolygon[1]&&p0[2]===simplePolygon[2]}function isFlatRingClosed(positions,size,startIndex,endIndex){for(var i=0;i<size;i++)if(positions[startIndex+i]!==positions[endIndex-size+i])return!1;return!0}function copyNestedRing(target,targetStartIndex,simplePolygon,size){for(var len=simplePolygon.length,i=0;i<len;i++)for(var j=0;j<size;j++)target[targetStartIndex++]=simplePolygon[i][j]||0;if(!isNestedRingClosed(simplePolygon))for(len=0;len<size;len++)target[targetStartIndex++]=
simplePolygon[0][len]||0;return targetStartIndex}function copyFlatRing(target,targetStartIndex,positions,size){var srcStartIndex=4<arguments.length&&void 0!==arguments[4]?arguments[4]:0,srcEndIndex=5<arguments.length?arguments[5]:void 0;srcEndIndex=srcEndIndex||positions.length;var srcLength=srcEndIndex-srcStartIndex;if(0>=srcLength)return targetStartIndex;for(var targetIndex=targetStartIndex,i=0;i<srcLength;i++)target[targetIndex++]=positions[srcStartIndex+i];if(!isFlatRingClosed(positions,size,
srcStartIndex,srcEndIndex))for(srcEndIndex=0;srcEndIndex<size;srcEndIndex++)target[targetIndex++]=positions[srcStartIndex+srcEndIndex];return targetIndex}function getNestedVertexCount(simplePolygon){return(isNestedRingClosed(simplePolygon)?0:1)+simplePolygon.length}function getFlatVertexCount(positions,size){var startIndex=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0,endIndex=3<arguments.length?arguments[3]:void 0;endIndex=endIndex||positions.length;return startIndex>=endIndex?0:(isFlatRingClosed(positions,
size,startIndex,endIndex)?0:1)+(endIndex-startIndex)/size}function getVertexCount(polygon,positionSize){if(2<arguments.length&&void 0!==arguments[2]&&!arguments[2])return polygon=polygon.positions||polygon,polygon.length/positionSize;validate(polygon);if(polygon.positions){var _polygon=polygon,positions=_polygon.positions;if(_polygon=_polygon.holeIndices){for(var vertexCount=0,i=0;i<=_polygon.length;i++)vertexCount+=getFlatVertexCount(polygon.positions,positionSize,_polygon[i-1],_polygon[i]);return vertexCount}polygon=
positions}if(Number.isFinite(polygon[0]))return getFlatVertexCount(polygon,positionSize);if(!isSimple(polygon)){_polygon=0;positions=!0;var _didIteratorError=!1,_iteratorError=void 0;try{for(vertexCount=polygon[Symbol.iterator]();!(positions=(i=vertexCount.next()).done);positions=!0)_polygon+=getNestedVertexCount(i.value)}catch(err){_didIteratorError=!0,_iteratorError=err}finally{try{if(!positions&&null!=vertexCount["return"])vertexCount["return"]()}finally{if(_didIteratorError)throw _iteratorError;
}}return _polygon}return getNestedVertexCount(polygon)}global=require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0});exports.getVertexCount=getVertexCount;exports.normalize=function(polygon,positionSize,vertexCount){validate(polygon);vertexCount=vertexCount||getVertexCount(polygon,positionSize);vertexCount=new Float64Array(vertexCount*positionSize);var holeIndices=[];if(polygon.positions){var _polygon2=polygon;polygon=_polygon2.positions;
if(_polygon2=_polygon2.holeIndices){for(var targetIndex=0,i=0;i<=_polygon2.length;i++)targetIndex=copyFlatRing(vertexCount,targetIndex,polygon,positionSize,_polygon2[i-1],_polygon2[i]),holeIndices.push(targetIndex);holeIndices.pop();return{positions:vertexCount,holeIndices:holeIndices}}}if(Number.isFinite(polygon[0]))return copyFlatRing(vertexCount,0,polygon,positionSize),vertexCount;if(!isSimple(polygon)){_polygon2=0;var _iteratorNormalCompletion2=!0,_didIteratorError2=!1,_iteratorError2=void 0;
try{for(targetIndex=polygon[Symbol.iterator]();!(_iteratorNormalCompletion2=(i=targetIndex.next()).done);_iteratorNormalCompletion2=!0)_polygon2=copyNestedRing(vertexCount,_polygon2,i.value,positionSize),holeIndices.push(_polygon2)}catch(err){_didIteratorError2=!0,_iteratorError2=err}finally{try{if(!_iteratorNormalCompletion2&&null!=targetIndex["return"])targetIndex["return"]()}finally{if(_didIteratorError2)throw _iteratorError2;}}holeIndices.pop();return{positions:vertexCount,holeIndices:holeIndices}}copyNestedRing(vertexCount,
0,polygon,positionSize);return vertexCount};exports.getSurfaceIndices=function(normalizedPolygon,positionSize,preproject){var holeIndices=null;normalizedPolygon.holeIndices&&(holeIndices=normalizedPolygon.holeIndices.map(function(positionIndex){return positionIndex/positionSize}));normalizedPolygon=normalizedPolygon.positions||normalizedPolygon;if(preproject){preproject=normalizedPolygon.length;normalizedPolygon=normalizedPolygon.slice();for(var i=0;i<preproject;i+=positionSize)normalizedPolygon[i+
1]=Math.log(Math.tan(PI_4+normalizedPolygon[i+1]*DEGREES_TO_RADIANS_HALF))}return(0,_earcut["default"])(normalizedPolygon,holeIndices,positionSize)};var _earcut=global(require("module$node_modules$earcut$src$earcut")),PI_4=Math.PI/4,DEGREES_TO_RADIANS_HALF=Math.PI/360}
//# sourceMappingURL=module$node_modules$$luma_DOT_gl$experimental$dist$es5$gpgpu$point_in_polygon$polygon.js.map

{
"version":3,
"file":"module$node_modules$$loaders_DOT_gl$tiles$dist$es5$tileset$helpers$bounding_volume.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/@loaders_DOT_gl/tiles/dist/es5/tileset/helpers/bounding-volume.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$loaders_DOT_gl$tiles$dist$es5$tileset$helpers$bounding_volume\"] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createBoundingVolume = createBoundingVolume;\n\nvar _readOnlyError2 = _interopRequireDefault(require(\"@babel/runtime/helpers/readOnlyError\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _core = require(\"@math.gl/core\");\n\nvar _culling = require(\"@math.gl/culling\");\n\nvar _geospatial = require(\"@math.gl/geospatial\");\n\nvar _loaderUtils = require(\"@loaders.gl/loader-utils\");\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\nvar scratchMatrix = new _core.Matrix3();\nvar scratchScale = new _core.Vector3();\nvar scratchNorthWest = new _core.Vector3();\nvar scratchSouthEast = new _core.Vector3();\nvar scratchTransform = new _core.Matrix4();\n\nfunction createBoundingVolume(boundingVolumeHeader, transform, result) {\n  (0, _loaderUtils.assert)(boundingVolumeHeader, '3D Tile: boundingVolume must be defined');\n\n  if (boundingVolumeHeader.box) {\n    return createBox(boundingVolumeHeader.box, transform, result);\n  }\n\n  if (boundingVolumeHeader.region) {\n    var _boundingVolumeHeader = (0, _slicedToArray2[\"default\"])(boundingVolumeHeader.region, 6),\n        west = _boundingVolumeHeader[0],\n        south = _boundingVolumeHeader[1],\n        east = _boundingVolumeHeader[2],\n        north = _boundingVolumeHeader[3],\n        minHeight = _boundingVolumeHeader[4],\n        maxHeight = _boundingVolumeHeader[5];\n\n    var northWest = _geospatial.Ellipsoid.WGS84.cartographicToCartesian([(0, _core.degrees)(west), (0, _core.degrees)(north), minHeight], scratchNorthWest);\n\n    var southEast = _geospatial.Ellipsoid.WGS84.cartographicToCartesian([(0, _core.degrees)(east), (0, _core.degrees)(south), maxHeight], scratchSouthEast);\n\n    var centerInCartesian = new _core.Vector3().addVectors(northWest, southEast).multiplyScalar(0.5);\n    var radius = new _core.Vector3().subVectors(northWest, southEast).len() / 2.0;\n    return createSphere([centerInCartesian[0], centerInCartesian[1], centerInCartesian[2], radius], new _core.Matrix4());\n  }\n\n  if (boundingVolumeHeader.sphere) {\n    return createSphere(boundingVolumeHeader.sphere, transform, result);\n  }\n\n  throw new Error('3D Tile: boundingVolume must contain a sphere, region, or box');\n}\n\nfunction createBox(box, transform, result) {\n  var center = new _core.Vector3(box[0], box[1], box[2]);\n  transform.transform(center, center);\n  var xAxis = transform.transformAsVector(box.slice(3, 6));\n  var yAxis = transform.transformAsVector(box.slice(6, 9));\n  var zAxis = transform.transformAsVector(box.slice(9, 12));\n  var halfAxes = new _core.Matrix3([xAxis[0], xAxis[1], xAxis[2], yAxis[0], yAxis[1], yAxis[2], zAxis[0], zAxis[1], zAxis[2]]);\n\n  if (defined(result)) {\n    result.center = center;\n    result.halfAxes = halfAxes;\n    return result;\n  }\n\n  return new _culling.OrientedBoundingBox(center, halfAxes);\n}\n\nfunction createBoxFromTransformedRegion(region, transform, initialTransform, result) {\n  var rectangle = Rectangle.unpack(region, 0, scratchRectangle);\n  var minimumHeight = region[4];\n  var maximumHeight = region[5];\n\n  var orientedBoundingBox = _culling.OrientedBoundingBox.fromRectangle(rectangle, minimumHeight, maximumHeight, _geospatial.Ellipsoid.WGS84, scratchOrientedBoundingBox);\n\n  var center = orientedBoundingBox.center;\n  var halfAxes = orientedBoundingBox.halfAxes;\n  transform = _core.Matrix4.multiplyTransformation(transform, _core.Matrix4.inverseTransformation(initialTransform, scratchTransform), scratchTransform);\n  center = ((0, _readOnlyError2[\"default\"])(\"center\"), _core.Matrix4.multiplyByPoint(transform, center, center));\n\n  var rotationScale = _core.Matrix4.getRotation(transform, scratchMatrix);\n\n  halfAxes = ((0, _readOnlyError2[\"default\"])(\"halfAxes\"), _core.Matrix3.multiply(rotationScale, halfAxes, halfAxes));\n\n  if (defined(result) && result instanceof TileOrientedBoundingBox) {\n    result.update(center, halfAxes);\n    return result;\n  }\n\n  return new TileOrientedBoundingBox(center, halfAxes);\n}\n\nfunction createRegion(region, transform, initialTransform, result) {\n  if (!_core.Matrix4.equalsEpsilon(transform, initialTransform, CesiumMath.EPSILON8)) {\n    return createBoxFromTransformedRegion(region, transform, initialTransform, result);\n  }\n\n  if (defined(result)) {\n    return result;\n  }\n\n  var rectangleRegion = Rectangle.unpack(region, 0, scratchRectangle);\n  return new TileBoundingRegion({\n    rectangle: rectangleRegion,\n    minimumHeight: region[4],\n    maximumHeight: region[5]\n  });\n}\n\nfunction createSphere(sphere, transform, result) {\n  var center = new _core.Vector3(sphere[0], sphere[1], sphere[2]);\n  transform.transform(center, center);\n  var scale = transform.getScale(scratchScale);\n  var uniformScale = Math.max(Math.max(scale[0], scale[1]), scale[2]);\n  var radius = sphere[3] * uniformScale;\n\n  if (defined(result)) {\n    result.center = center;\n    result.radius = radius;\n    return result;\n  }\n\n  return new _culling.BoundingSphere(center, radius);\n}\n//# sourceMappingURL=bounding-volume.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","createSphere","sphere","transform","result","center","_core","Vector3","scale","getScale","scratchScale","radius","Math","max","uniformScale","undefined","_culling","BoundingSphere","_interopRequireDefault","Object","defineProperty","value","createBoundingVolume","boundingVolumeHeader","_loaderUtils","assert","box","xAxis","transformAsVector","slice","yAxis","zAxis","halfAxes","Matrix3","OrientedBoundingBox","region","_boundingVolumeHeader","_slicedToArray2","west","south","east","north","minHeight","maxHeight","northWest","_geospatial","Ellipsoid","WGS84","cartographicToCartesian","degrees","scratchNorthWest","southEast","scratchSouthEast","centerInCartesian","addVectors","multiplyScalar","subVectors","len","Matrix4","Error"]
}

{"version":3,"sources":["sci/impl/analyzer.cljc"],"mappings":";AAkBA,AAAA,AAAA,AAAKA;AAIL,AAAA,AAAA,AAAKC;AAKL,AAAA,AAAAC,AAAMQ,AAA0CC,AAAUC;AAA1D,AAAA,AAAAT,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAC,AAAA,AAAAD,AAAA,AAAA,AAAA,AAAA,AAAAE,AAAAC,AAAAH,AAAAA;AAAAI,AAAA,AAAAC,AAAAL,AAAA;AAAAM,AAAA,AAAAD,AAAAL,AAAA;AAAA,AACE,AAAU,AAAAU,AAAA;AAAAC,AAAsB,AAAA,AAAA,AAAIF,AAAII;AAA9B,AAAA,AAAAH,AAAAC,AAAAD,AAAAC,AAACC,AAAAA,AAAAA;;AAAX;;AAAA,AACE,AAAMJ,AAAU,AAACM,AAAcN;AAA/B,AACE,AAAU,AAAA,AAAIJ,AAAM,AAACW,AAAUX,AAAMI;AAArC;AAAA,AAEE,AAACQ,AAA0B,AAAA,AAAKP,AAAwBA;;;AAC1D,AAAM,AAAA,AAAIH,AAAK,AAACS,AAAUT,AAAKE;AAA/B,AAEE,AAACQ,AAA0B,AAAA,AAAKP,AAAwBA;;AAF1D;;;;AAIN,AAAA,AAAAQ,AAAMG,AAAgCX,AAAIa;AAA1C,AAAA,AAAAJ,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAjB,AAAA,AAAAiB,AAAA,AAAA,AAAA,AAAA,AAAAhB,AAAAC,AAAAe,AAAAA;AAAAA,AAAiCG;AAAjCF,AAAA,AAAAd,AAAAa,AAAA;AAAA,AACE,AAAMM,AAAO,AAAAC,AAAQ,AAACC,AAAUjB;AAAnB,AAAA,AAAA,AAAAgB,AAAA;AAAA;;AAAA,AAAAA,AAAwBE;;;AAC/BC,AAAS,AAACD,AAAO,AAACE,AAAKpB;AAD7B,AAAAc,AAEMJ,AAAKA;AACLW,AAAI,AAACC;AACLC,AAAe,AAAAC,AAAA,AAAA,AAAId;AAAJ,AAAA,AAAAc,AAAAA,AAAoBH,AAAAA,AAAAA;;AAEnCN,AAAO,AAAA,AAAMA,AAAO,AAAAU,AAAI,AAAA,AAAA,AAACC,AAAOH,AAAyBR;AAArC,AAAA,AAAAU;AAAAA;;AACIV;;AADjB;AANb,AAQE,AAAAU,AAAI,AAACE,AAAKJ,AAAevB;AAAzB,AAAA,AAAAyB;AAAAA;;AACI,AACE,AAAAG,AAAKb;AAAL,AAAA,AAAAa;AAAY,AAAI,AAAA,AAAA,AAACC,AAAEd,AAAsB,AAAA,AAAA,AAACc,AAAEd;;AAA5Ca;;;AACA,AAAAH,AAAI,AAAAK,AAAQpB;AAARoB,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAAA;AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAwB,AAAAA,AAAA,AAAA,AAAClC;AAAzB,AAAA,AAAA,AAAAkC,AAAA;AAAA;;AAA4C,AAAAA,AAACH,AAAKR;;;AAAtD,AAAA,AAAAM;AAAAA;;AACI,AAAAM,AAAa,AAAA,AAAA,AAAMlB,AAAM,AAACjB,AAAIP,AAAO8B;AAArC,AAAA,AAAAY;AAAA,AAAA,AAAAA,AAAWC;AAAX,AAAA,AACGhC,AAAIgC;;AADP;;;;AAHN,AAKEjB;AACA,AAAAU,AAAI,AAAAQ,AAAQvB;AAARuB,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAAA;AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAAA,AAAAA,AAAwBlB,AAAAA,AAAAA;AAAxB,AAAA,AAAA,AAAAkB,AAAA;AAAA;;AAA+B,AAAAA,AAACN,AAAKR;;;AAAzC,AAAA,AAAAM;AAAAA;;AACI,AAAAM,AAAiB,AAACI,AAAsBvB,AAAIG;AAA5C,AAAA,AAAAgB;AAAA,AAAA,AAAAA,AAAWG;AAAX,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AACGlC,AAAoCkC,AAAMf;;AAD7C;;;;AAPN,AAWE,AAAU,AAACb,AACA,AAAA,AAAA,AAAA,AAAA,AAAA,AAACoB,AAAOH,AAAgDJ;AADnE;;AAAA,AAEE,AAAAM,AACC,AAAAW,AAAQ1B;AAAR0B,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAAA;AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAwB,AAAAA,AAAA,AAAA,AAACxC;AAAzB,AAAA,AAAA,AAAAwC,AAAA;AAAA;;AAA4C,AAAAA,AAACT,AAAKR;;;AADnD,AAAA,AAAAM;AAAAA;;AAAA,AAAAA,AAEC,AAAA,AAAA,AAAA,AAAM,AAAA,AAAA,AAAMZ,AAAM,AAACjB,AAAIP,AAAOW,AAC3BA,AAAIA;AAHR,AAAA,AAAAyB;AAAAA;;AAIC,AAAAM,AAAa,AAACI,AAAsBvB,AAAIZ;AAAxC,AAAA,AAAA+B;AAAA,AAAA,AAAAA,AAAWM;AAAX,AAAA,AACGrC,AAAIqC;;AADP;;;;;;;;;;AAGb,AAAA,AAAMC,AAAKC,AAAKC;AAAhB,AACE,AAAAT,AAAa,AAAC3B,AAAKoC;AAAnB,AAAA,AAAAT;AAAA,AAAA,AAAAA,AAAWU;AAAX,AACE,AAAA,AAAMA;;AADR;;;AAGF,AAAA,AAAAC,AAAMG,AAAoC7C,AAAIa;AAA9C,AAAA,AAAA8B,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAnD,AAAA,AAAAmD,AAAA,AAAA,AAAA,AAAA,AAAAlD,AAAAC,AAAAiD,AAAAA;AAAAA,AAAqC/B;AAArCgC,AAAA,AAAAhD,AAAA+C,AAAA;AAAA,AACE,AAAAG,AACM,AAAArB,AAEC,AAAAM,AACW,AAACJ,AAAKiB,AAAS5C;AAD1B,AAAA,AAAA+B;AAAA,AAAA,AAAAmB,AAAAnB;AAAA,AAAAgB,AAAAG,AAAA,AAAA,AAAYF;AAAZ,AAAAD,AAAAG,AAAA,AAAA,AAAclB;AAAd,AAGE,AAAMmB,AAAE,AAACb,AAAI1B,AAAIoB;AACXA,AAAE,AAACoB,AAAiBJ;AAEpBhB,AAAE,AAAImB,AAAE,AAAA,AAACE,AAAUrB,AACAsB,AAAWH,AACxBnB;AALZ,AAAA,AAMGgB,AAAEhB;;AATP;;;AAFD,AAAA,AAAAP;AAAAA;;AAYC,AAAAM,AAGM,AAACpB,AAAQC,AAAIZ,AAAIa;AAHvB,AAAA,AAAAkB;AAAA,AAAA,AAAAwB,AAAAxB;AAAA,AAAAgB,AAAAQ,AAAA,AAAA,AACMP;AADN,AAAAD,AAAAQ,AAAA,AAAA,AACQC;AADRD,AACcN;AADd,AAME,AAACnD,AAAkBc,AAAIoC,AAAEhD;;AACzBiD;;AAPF;;;;AAbP,AAAAF,AAAAD,AAAA,AAAA,AAAOE;AAAP,AAAAD,AAAAD,AAAA,AAAA,AAASd;AAATc,AAAeG;AAAf,AAsBE,AAAAQ,AAAW,AAAA,AAAK,AAACC,AAAI,AAAA,AAAyB9C,AAC9B,AAACR,AAAK4C;AADtB,AAAA,AAAAS;AAAA,AAAAA,AAAShB;AAAT,AAEE,AAAI,AAAA,AAAkBA;AAAtB,AAGGO,AAAE,AAAA,AAAA,AAAA,AAAA,AAACW,AAAW3B;;AAEfiB;;;AACFA;;;AAEN,AAAA,AAAA,AAAAW,AAAME;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMD,AACFlD,AAAIZ;AADR,AACa,AAAA,AAACgE,AAAepD,AAAIZ;;;AADjC,AAAA,AAAA,AAAM8D,AAEFlD,AAAIZ,AAAIa;AAFZ,AAGG,AAAMb,AAAIA;AACJiE,AAAI,AAACC,AACA,AAAAzC,AACC,AAACoB,AAAOjC,AAAIZ,AAAIa;AADjB,AAAA,AAAAY;AAAAA;;AAIC,AAAM0C,AAAE,AAAC/C,AAAKpB;AAAd,AACE,AACE,AAAA4B,AAAKf;AAAL,AAAA,AAAAe;AAAA,AACK,AAAA,AAACwC,AAAiBD,AAClB,AAAA,AAAG,AAAOA;;AAFfvC;;;AADF,AAAA,AAAA,AAIG5B;;AAJH,AAKE,AAAA4B,AAAKf;AAAL,AAAA,AAAAe;AAAA,AACK,AAAA,AAACyC,AAAeF,AAChB,AAAA,AAAG,AAAOA;;AAFfvC;;;AALF,AAAA,AAAA,AAQG5B;;AARH,AASE,AAAA,AAACoE,AAAiBD;AAClB,AAAMnC,AAAE,AAACd,AAAO,AAAA,AAACoD,AAAKH;AAAtB,AAAA,AACGnC,AAAEA;;AAXP,AAYQ,AAACzB,AACA,AAAA,AAAkC,AAAKP,AACvCA;;;;;;;AArBvB,AAuBEiE;;;AA1BL,AAAA,AAAA,AAAMH;;AAAN,AA4BA,AAAA,AAEA,AAAA,AAAMS,AAAkB3D,AAAI4D;AAA5B,AACE,AAAA,AAAAC,AAACC;AAAD,AAAO,AAAAD,AAAAA,AAACE,AAAAA,AAAAA,AAAQ/D,AAAAA;AAAO4D;;AAEzB,AAAA,AAAMI,AACHC,AAAOC;AADV,AAEE,AAAI,AAACC,AAAOC,AAAQH;AAApB,AAAA,AAAA,AACWA,AACFC;;AACP,AAAOD,AAAOA;AACPI,AAAW,AAAA,AAACtB,AAAa,AAACvD,AAAKyE;AADtC,AAEOK;;AAFP,AAGE,AAAIL;AACF,AAAI,AAAAU,AAAS,AAACC,AAAMX;AAClB,AAAO,AAACY,AAAKZ;AAAQ,AAACa,AAAKT,AAAW,AAACO,AAAMX;AAASK;;;;;;AACtD,AAAMS,AAAO,AAAA,AAACC;AAAd,AACE,AAAO,AAACH,AAAKZ;AAAQ,AAACa,AAAKT,AAAWU;AAC3BT,AAAK,AAACQ,AAAK,AAACF,AAAMX,AAAS,AAACa,AAAKC;;;;;;;AALlD,AAAA,AAAA,AAAA,AAAA,AAAAR,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAMWL,AACMC,AACFJ;;;;;;AAErB,AAAA,AAAAe,AAAAC,AAAMM,AAAgDC,AAAsCG;AAA5F,AAAA,AAAAT,AAAAF;AAAAE,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAvG,AAAA,AAAAuG,AAAA,AAAA,AAAA,AAAA,AAAAtG,AAAAC,AAAAqG,AAAAA;AAAAA,AAAiDnF;AAAjDoF,AAAA,AAAApG,AAAAmG,AAAA;AAAAE,AAAAH;AAAAI,AAAA,AAAAd,AAAAa;AAAAE,AAAA,AAAAX,AAAAU;AAAAA,AAAA,AAAAT,AAAAS;AAAAC,AAA+DG;AAA/DJ,AAAgFK;AAAhF,AACE,AAAUD;AAAV;AAAA,AACE,AAAA,AAAC/F,AAA2DyF;;;AAC9D,AAAU,AAACS,AAAQH;AAAnB;AAAA,AACE,AAAA,AAAC/F,AAAqEyF;;;AACxE,AAAMM,AAAe,AAAIE,AAAO,AAAA,AAAA,AAAA,AAAA,AAAA,AAACG,AAAoBL,AAC5BA;AACnBM,AAAW,AAAA,AAAAC,AAACC;AAAD,AAAa,AAAA,AAAA,AAAAD,AAACE;AAAWT;AACpCU,AAAY,AAACC,AAAML;AACnBM,AAAa,AAAChD,AAAO,AAAA,AAAAiD,AAACC;AAAD,AAAa,AAAA,AAAA,AAAAD,AAACJ;AAAWT;AAC9Ce,AAAU,AAAC5B,AAAKc;AAChBe,AAAM,AAAA,AAAMD,AACJ,AAAME,AAAE,AAAC/B,AAAMe;AAAf,AACE,AAAM,AAACiB,AAAKD;AAAZ,AAAeA;;AAAf;;AAFJ;AAGNhB,AAAW,AAAIe,AAAMD,AAAUd;AAC/Be,AAAM,AAAA7F,AAAI6F;AAAJ,AAAA,AAAA7F;AAAAA;;AAAU,AAACrB,AAAKkG;;;AACtBmB,AAAI,AAAA,AAAMH;AACVI,AAAK,AAAA,AAAOJ;AACZf,AAAW,AAAA,AAAApB,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAAH,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAqC,AAAA,AAAAxC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAIoC,AACW,AAAA,AAAAvC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAI,AAAA,AAAK,AAAC2B,AAAMV,AACPA,AACP,AAACf,AAAMe,AAChB,AAACqB,AAAI,AAAMvF;AAAN,AAAA,AAAA8C,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAmBjD;AAJhC,AAAAiD,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAIoCoC,AAElCnB;AACbA,AAAW,AAAIkB,AACF,AAACpC,AAAO,AAACuC,AAAI,AAAMvF;AAAN,AAAA,AAAA8C,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAmBjD;AAAIoF,AAC5BlB,AACRA;AAvBnBG,AAwB8B,AAAC9B,AAAmB0B,AAAeC;AAxBjEG,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAlH,AAAA,AAAAkH,AAAA,AAAA,AAAA,AAAA,AAAAjH,AAAAC,AAAAgH,AAAAA;AAAA7B,AAAA,AAAAjF,AAAA8G,AAAA;AAAA5B,AAAA,AAAAlF,AAAA8G,AAAA;AAyBM9F,AAAI,AAAA,AAACiH,AAAOjH,AAAckH,AAAM,AAACC,AAAOlD,AACA,AAAA,AAACmD;AACzClD,AAAK,AAACP,AAAiB3D,AAAIkE;AA3BjC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AA4BmBA,AACED,AACKmC,AACCE,AACLb;;AAExB,AAAA,AAAA4B,AAAMI,AAAWzH,AAAmC4F;AAApD,AAAA,AAAA0B,AAAAD;AAAAE,AAAA,AAAA/C,AAAA8C;AAAAE,AAAA,AAAA5C,AAAA2C;AAAAA,AAAA,AAAA1C,AAAA0C;AAAAC,AAAsBE;AAAtBF,AAAA,AAAA5C,AAAA2C;AAAAA,AAAA,AAAA1C,AAAA0C;AAAAC,AAA0BG;AAA1BJ,AAAkCrD;AAAlCoD,AAA2ClC;AAA3C,AACE,AAAMpF,AAAI,AAAA,AAAC4H,AAAM5H,AAAaoF;AACxBK,AAAQ,AAAA,AAAI,AAAAd,AAASgD,AACXA;AAEVzD,AAAK,AAAIuB,AACFvB,AACA,AAAC2D,AAAKF,AAAMzD;AAEnB4D,AAAO,AAAA,AAAI,AAACC,AAAK,AAACnD,AAAMV,AACfA,AACCA;AACVlE,AAAI,AAAIyF,AAAQ,AAAA,AAAA,AAAA,AAACuC,AAAShI,AAAeyF,AACjCzF;AACRiI,AAAgB,AAACC,AACA,AAAAC,AAA+CjE;AAA/C,AAAA,AAAAkE,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAxJ,AAAA,AAAAwJ,AAAA,AAAA,AAAA,AAAA,AAAAvJ,AAAAC,AAAAsJ,AAAAA;AAAAA,AAA0CG;AAA1CF,AAAA,AAAArJ,AAAAoJ,AAAA;AAAAE,AAAA,AAAAtJ,AAAAoJ,AAAA;AAAA,AACE,AAAMI,AAAQ,AAAC5D,AAAMV;AACfA,AAAK,AAACsB,AAAoBxF,AAAIyF,AAAQvB,AAAK0B;AAC3C1B,AAAK,AAAA,AAAC0D,AAAM1D,AAAuBsE;AACnClC,AAAa,AAAA,AAAwBpC;AACrCkC,AAAY,AAAA,AAAuBlC;AACnCuE,AAAgB,AAAA,AAAA,AAAMnC,AAAaF;AALzC,AAME,AAAM,AAAApF,AAAKsF;AAAL,AAAA,AAAAtF;AAAkBsH;;AAAlBtH;;;AAAN,AACE,AAAA,AAACrB,AAAqEyF;;AADxE;;AAEA,AAAM,AAAA,AAAApE,AAAK,AAAC8B,AAAIwD,AAAcgC;AAAxB,AAAA,AAAAtH;AAAoC,AAAGoF,AAAYkC;;AAAnDtH;;AAAA;AAAN,AACE,AAAA,AAACrB,AAC0EyF;;AAF7E;;AAGImD,AACA,AAAA,AAAA,AAACX,AAAmBa,AACF,AAAAC,AAAK,AAAA,AAAuBxE,AAE9C,AAAC+C,AACD,AAACA;AAHiB0B,AACKN;AADL,AAAA,AAAAK,AAAAC,AAAAD,AAAAC;AAElB,AAAgBC,AAAK1E,AACrB,AAAkB0E,AAAKJ;AAlBhC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAsBiBV;AACjCe,AAAQ,AAAA,AAASZ;AACjBa,AAAS,AAAA,AAAWb;AArC1B,AAsCE,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAClF,AAAgC8F,AACFpD,AACCqD;;AAIpC,AAAA,AAAMC,AACH/I,AAAIgJ,AAA0BC;AADjC,AAEE,AAAAC,AACM,AAAChB,AACA,AAAAkB,AAAAC;AAAA,AAAA,AAAAC,AAAAF;AAAA,AAAAjH,AAAAmH,AAAA,AAAA,AAAMtJ;AAAN,AAAAmC,AAAAmH,AAAA,AAAA,AAAUH;AAAVI,AAAAF;AAAA,AAAAlH,AAAAoH,AAAA,AAAA,AAA6BC;AAA7B,AAAArH,AAAAoH,AAAA,AAAA,AAA0CE;AAA1C,AACE,AAAMrI,AAAE,AAAC2C,AAAAA,AAAAA,AAAQ/D,AAAAA,AAAIyJ,AAAAA;AAArB,AAAA,AACG,AAAA,AAACxC,AAAOjH,AAAc0C,AAAM8G,AAAapI,AACzC,AAAC0D,AAAKqE,AAAiBK,AAAapI;AAJ1C,AAAA,AAKEpB,AACD,AAAA,AAAC0J,AAAYV;AAPpB,AAAA7G,AAAA+G,AAAA,AAAA,AAAOlJ;AAAP,AAAAmC,AAAA+G,AAAA,AAAA,AAAWC;AAAX,AAQE,AAAA,AAAA5E,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAACiF,AAAwBR,AAAmB,AAACxF,AAAiB3D,AAAIiJ;;AAEtE;;;AAAA,AAAAW,AAAMI,AAEHhK;AAFH,AAAA,AAAA6J,AAAAD;AAAAE,AAAA,AAAAtF,AAAAqF;AAAAE,AAAA,AAAAnF,AAAAkF;AAAAA,AAAA,AAAAjF,AAAAiF;AAAAC,AAEQE;AAFRF,AAAA,AAAAnF,AAAAkF;AAAAA,AAAA,AAAAjF,AAAAiF;AAAAC,AAEaG;AAFbJ,AAE6Bb;AAF7B,AAGE,AAAMiB,AAAa,AAACC,AAAYD;AAAhC,AACE,AAACnB,AAAY/I,AAAIkK,AAAajB;;AAElC;;;AAAA,AAAAmB,AAAMI,AAEHxK;AAFH,AAAA,AAAAqK,AAAAD;AAAAE,AAAA,AAAA9F,AAAA6F;AAAAE,AAAA,AAAA3F,AAAA0F;AAAAA,AAAA,AAAAzF,AAAAyF;AAAAC,AAEQE;AAFRH,AAEYI;AAFZ,AAGE,AAAMC,AACA,AAAOF,AAAEA;AAAGC,AAAMA;;AAAlB,AACE,AAAIA;AACF,AAAME,AAAK,AAAChG,AAAM8F;AACZG,AAAS,AAAI,AAAC9C,AAAK6C,AACR,AAAC7H,AAAU,AAAC0B,AAAO,AAAAC,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAM,AAACE,AAAMgG,AAAMH,AACnB,AAAC5F,AAAK+F,AACvB,AAACpL,AAAKoL,AACR,AAAAlG,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAMkG,AAAKH;AAL5B,AAME,AAAOI;AAAS,AAAChG,AAAK6F;;;;;AAASD;;;;;AAT3C,AAUE,AAAC1G,AAAAA,AAAAA,AAAQ/D,AAAAA,AAAI2K,AAAAA;;AAEjB;;;AAAA,AAAAG,AAAMI,AAEHlL;AAFH,AAAA,AAAA+K,AAAAD;AAAAE,AAAA,AAAAxG,AAAAuG;AAAAE,AAAA,AAAArG,AAAAoG;AAAAA,AAAA,AAAAnG,AAAAmG;AAAAC,AAEQE;AAFRF,AAAA,AAAArG,AAAAoG;AAAAA,AAAA,AAAAnG,AAAAmG;AAAAC,AAEYrJ;AAFZqJ,AAAA,AAAArG,AAAAoG;AAAAA,AAAA,AAAAnG,AAAAmG;AAAAC,AAEiBG;AAFjBJ,AAEwBN;AAFxB,AAGE,AAAAW,AAAA,AAAA9G,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAAqC,AAAA,AAAAxC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAgC0G,AAAMxJ,AACL,AAAC4J,AAAW,AAACpE,AAAOgE,AAAM,AAACK,AAAQf,AACrC,AAAI,AAACgB,AAAOhB,AACVU,AACA,AAACO,AAAKjB;AAJvCY,AAAA,AAAA9G,AAAA6G;AAAAE,AAAA,AAAA3G,AAAA0G;AAAAA,AAAA,AAAAzG,AAAAyG;AAAAC,AAAOrB;AAAPoB,AAAsBpH;AAAtB,AAKE,AAAC6E,AAAY/I,AAAIkK,AAAahG;;AAElC,AAAA,AAEA,AAAA,AAAA0H,AAAME,AACH9L;AADH,AAAA,AAAA6L,AAAAD;AAAA,AAAAzJ,AAAA0J,AAAA,AAAA,AACQE;AADR,AAAA5J,AAAA0J,AAAA,AAAA,AACaG;AADb,AAAA7J,AAAA0J,AAAA,AAAA,AACsBI;AADtB,AAAA9J,AAAA0J,AAAA,AAAA,AACiCK;AADjCL,AAC2CjK;AAD3C,AAEE,AAAAuK,AAAgBnM;AAAhBoM,AAAA,AAAA,AAAyBJ;AAAzB,AAAA,AAAAG,AAAAC,AAAAD,AAAAC,AAACC,AAAAA,AAAAA;;AACD,AAAU,AAACC,AAAeN;AAA1B;AAAA,AACE,AAAA,AAACrM,AAA8DiC;;;AACjE,AAAM2K,AAAU,AAAA,AAAA,AAAML,AAAMD;AACtBO,AAAK,AAAID,AAAUL,AAAMD;AACzBO,AAAK,AAAA,AAAI,AAAA,AAACvL,AAAE,AAACoF,AAAMzE,AAEZ,AAACmC,AAAAA,AAAAA,AAAQ/D,AAAAA,AAAIwM,AAAAA;AACpB3K,AAAE,AAACrC,AAAKwM;AACRnK,AAAE,AAACkC,AAAAA,AAAAA,AAAQ/D,AAAAA,AAAI6B,AAAAA;AACfA,AAAE,AAAA,AAAA,AAAA3B,AAAC0H,AAAM/F,AAAO4K;AAChB5K,AAAE,AAAI0K,AAAU,AAAA,AAAC3E,AAAM/F,AAAO0K,AAAW1K;AACzCmK,AAAS,AAACjJ,AAAUiJ,AAASnK;AATnC,AAUE,AAAA6K,AAAgB1M;AAAhB2M,AAAA,AAAA,AAAyBX;AAAzB,AAAA,AAAAU,AAAAC,AAAAD,AAAAC,AAACN,AAAAA,AAAAA;;AACD,AAAC1C,AAAe,AAAAjF,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAWsH,AAASQ;;AAExC,AAAA,AAAAI,AAAMI,AAAahN;AAAnB,AAAA,AAAA6M,AAAAD;AAAAE,AAAA,AAAAtI,AAAAqI;AAAAE,AAAA,AAAAnI,AAAAkI;AAAAA,AAAA,AAAAjI,AAAAiI;AAAAC,AAAwBE;AAAxBF,AAAA,AAAAnI,AAAAkI;AAAAA,AAAA,AAAAjI,AAAAiI;AAAAC,AAA2BtH;AAA3BqH,AAAqC5I;AAArC2I,AAA8CjL;AAA9C,AACE,AAAU,AAAC0K,AAAe7G;AAA1B;AAAA,AACE,AAAA,AAAC9F,AAA8DiC;;;AACjE,AAAAsL,AAAgBlN;AAAhBmN,AAAA,AAAA,AAAyB1H;AAAzB,AAAA,AAAAyH,AAAAC,AAAAD,AAAAC,AAACd,AAAAA,AAAAA;;AACD,AAAMzG,AAAO,AAAA,AAAC3E,AAAa,AAACT,AAAKyM;AAAjCG,AACsB,AAACE,AAAW,AAACC,AAAKzK,AAAI0K,AAAatJ;AADzD,AAAA/B,AAAAiL,AAAA,AAAA,AACOC;AADP,AAAAlL,AAAAiL,AAAA,AAAA,AACgBlJ;AACVtB,AAAE,AAAA,AAAA,AAAM,AAAC8I,AAAOxH,AACZ,AAAA,AAACvE,AAA2DiC;AAChE2K,AAAU,AAAApL,AAAc,AAACyD,AAAMyI;AAArB,AAAA,AAAAlM;AAAA,AAAA,AAAAA,AAAWsM;AAAX,AACE,AAAM,AAASA;AAAf,AAAmBA;;AAAnB;;;AADF;;;AAEVC,AAAS,AAAAvM,AAAa,AAACwK,AAAK0B;AAAnB,AAAA,AAAAlM;AAAA,AAAA,AAAAA,AAAWU;AAAX,AACE,AAAM,AAAC+E,AAAK/E;AAAZ,AAAeA;;AAAf;;;AADF;;;AAET6L,AAAS,AAAAC,AAAS3N;AAAT4N,AAAa,AAACC,AAAM,AAACrO,AAAKoC,AAAM8L;AAAhC,AAAA,AAAAC,AAAAC,AAAAD,AAAAC,AAAC7J,AAAAA,AAAAA;;AACV+J,AAAQ,AAAC/K,AAAU,AAAA,AAAA,AAAC8E,AAAS3D,AACnB,AAAC1E,AAAKoC;AAChBmM,AAAE,AAACtG,AAAUzH,AAAI8N,AAAQlI;AACzBkD,AAAS,AAACtE,AAAI,AAAA,AAAoBuJ;AAClCL,AAAS,AAAA,AAAA,AAAAxN,AAAA,AAAC0H,AAAM8F,AACKjB,AACK3D;AAC1BrD,AAAQ,AAAC1C,AAAU0C,AACT,AAAAuI,AAAQN;AAARM,AAAA,AAAAA,AACEzB,AAAU,AAAAyB,AAAA,AAACpG,AAAW2E;AADxB,AAAA,AAEE3G;AAAO,AAAAoI,AAAA,AAAA,AAACpG;;AAFVoG;;;AAGVD,AAAE,AAAA,AAAA,AAACnG,AAAMmG,AACWnI,AACOH;AAtBjC,AAuBE,AAACkE,AAAe,AAAAjF,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAWe,AAAQsI;;AAEvC,AAAA;;;AAAA,AAAA/K,AAAMsL;AAAN,AAAA,AAAAL,AAAA;AAAA,AAAA,AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAAE;;AAAA,AAAA,AAAAA,AAAA;;;;AAAA;;;;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAH,AAAA,AAAA,AAAAI,AAAA,AAAAJ,AAAA,AAAA,AAAA,AAAA;AAAA,AAAA,AAAAK,AAAA,AAAA,AAAA,AAAAF;;;AAAA,AAAA,AAAA,AAAA,AAAME,AAEH3M,AAAO+M;AAFV,AAAA;;;AAAA,AAAA,AAAA,AAAMJ;;AAAN;AAAA,AAAA,AAAA,AAAAC,AAAMD;AAAN,AAAA,AAAAE,AAAA,AAAA5J,AAAA2J;AAAAA,AAAA,AAAA1J,AAAA0J;AAAA,AAAA,AAAAE,AAAA;AAAA,AAAA,AAAAA,AAAAD,AAAAD;;;AAAA,AAIA,AAAA,AAAMI,AACH3O,AAAI4B;AADP,AAEE,AAAMgN,AAAG,AAACtL,AAAO1B;AACXiN,AAAU,AAAA,AAACC,AAAWF;AACtBG,AAAU,AAAA,AAACD,AAAW,AAACE,AAAKJ;AAC5B1K,AAAK,AAAC+K,AAAMrN;AAHlB,AAIE,AAAAsN,AAASlP;AAATmP,AAAa,AAAA,AAAA5K,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAC7F,AAAMuQ,AAAW,AAACrI,AAAI8H,AAAa3K,AAC7B6K;AADpB,AAAA,AAAAG,AAAAC,AAAAD,AAAAC,AAACpL,AAAAA,AAAAA;;AAGL,AAAA,AAAMsL,AACHrP,AAAI4B;AADP,AAEE,AAAMsC,AAAK,AAAC8K,AAAKpN;AAAjB,AACE,AAAC+H,AACA,AAAAjF,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AACM,AAAA4K,AAAStP;AAATuP,AAES,AAAA7K,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAa,AAAA,AAAA,AAACmD,AAAS3D;AAFhC,AAAA,AAAAoL,AAAAC,AAAAD,AAAAC,AAACxL,AAAAA,AAAAA;AADP,AAAA,AAAA,AAAA,AAAA;;AAKL,AAAA,AAAAyL,AAAMI,AACH5P;AADH,AAAA,AAAAyP,AAAAD;AAAAE,AAAA,AAAAlL,AAAAiL;AAAAE,AAAA,AAAA/K,AAAA8K;AAAAA,AAAA,AAAA7K,AAAA6K;AAAAC,AACQE;AADRH,AACczG;AADdwG,AACwB7N;AADxB,AAEE,AAAAkO,AAAM,AAACzJ,AAAM4C;AAAb,AAAA,AAAA6G;AAAA;AAAA;AACQ,AAAA,AAACnQ,AAAoDiC;;;AAD7D;AAAA;AAEQ,AAAA,AAAA2C,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAACiF,AAAwB,AAAChG,AAAiB3D,AAAIiJ;;;;AACrD,AAAA,AAACtJ,AAAqDiC;;;;AAE1D,AAAA,AAAMmO,AACH/P,AAAI4B;AADP,AAEE,AAAMR,AAAE,AAAA4O,AAAShQ;AAATiQ,AAAa,AAAC3M,AAAO1B;AAArB,AAAA,AAAAoO,AAAAC,AAAAD,AAAAC,AAAClM,AAAAA,AAAAA;;AACHmM,AAAQ,AAACjB,AAAMrN;AACfuO,AAAc,AAAA,AAACrB,AAAWoB;AAC1BE,AAAe,AAACzM,AAAiB3D,AAAI,AAAA,AAAC8O,AAAW,AAACE,AAAKkB;AACvDG,AAAQ,AAAA,AAAA,AAAA,AAAM,AAACC,AAAK,AAACjK,AAAM6J,AACX,AAAAK,AAASvQ;AAATwQ,AAAa,AAAC7E,AAAKuE;AAAnB,AAAA,AAAAK,AAAAC,AAAAD,AAAAC,AAACzM,AAAAA,AAAAA;AADT;AAER0M,AAAM,AAACjF,AAAW2E,AAAcC;AAChCM,AAAU,AAAK7O,AAAEO,AAAEhB;AAAT,AACE,AAAA,AAAQ,AAAC1B,AAAUmC,AAAEO;AACnB,AAACwF,AAAM/F,AAAEO,AAAEhB;;AACX,AAACzB,AAA0B,AAAA,AAAqCyC,AACrCR;;;AACzC+O,AAAS,AAAOF,AAAM,AAACjM,AAAIiM;AAAlB,AACOG;;AADP,AAEE,AAAIH;AACF,AAAAI,AAAoBJ;AAApBK,AAAA,AAAAtM,AAAAqM;AAAAE,AAAA,AAAAnM,AAAAkM;AAAAA,AAAA,AAAAjM,AAAAiM;AAAAC,AAAO3O;AAAP2O,AAAA,AAAAnM,AAAAkM;AAAAA,AAAA,AAAAjM,AAAAiM;AAAAC,AAAS3P;AAAT0P,AAAaL;AAAb,AACE,AAAI,AAACO,AAAM5O;AACT,AACCqO;AACA,AAACvI,AAAO;AAAKK,AAAInG;AAAT,AACE,AAACsO,AAAUnI,AAAInG,AAAEhB;;AACnBwP,AACAxO;;;;;AACT,AACCqO;AACA,AAACC,AAAUE,AAAQxO,AAAEhB;;;;;;AAC1BwP;;;;;AACbK,AAAI,AAACtH,AAAe,AAAAjF,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AACiBiM,AACAvP,AACIiP,AACfA;AA/BhC,AAgCE,AAAC1G,AAAesH;;AAEpB,AAAA,AAAAC,AAAMI,AACHtR;AADH,AAAA,AAAAmR,AAAAD;AAAAE,AAAA,AAAA5M,AAAA2M;AAAAE,AAAA,AAAAzM,AAAAwM;AAAAA,AAAA,AAAAvM,AAAAuM;AAAAC,AACQE;AADRH,AACelN;AADf,AAEE,AAAAsN,AAGM,AAAOvI,AAAqC,AAACzE,AAAIN;AAAjD,AACOyB;AADP,AAEOgM;AAFP,AAGOC;;AAHP,AAIE,AAAI3I;AACF,AAAMrH,AAAK,AAACgD,AAAMqE;AACZA,AAAM,AAACpE,AAAKoE;AADlB,AAEE,AAAM,AAAK,AAAClB,AAAKnG,AAAM,AAAA,AAAA,AAACX,AAAS,AAAC2D,AAAMhD;AAClC,AAAOqH;AAAMtD;AAAW,AAACb,AAAK6M,AAAY/P;AAAMgQ;;;;;;;AADtD,AAEM,AAAK,AAAC9O,AAAImG,AAAO,AAAK,AAAClB,AAAKnG,AAAM,AAAA,AAAA,AAACX,AAAW,AAAC2D,AAAMhD;AAF3D,AAGO+D,AAAWgM,AAAY/P;;AAH9B,AAOM,AAAOqH;AAAM,AAACnE,AAAKa,AAAW/D;AAAM+P;AAAYC;;;;;;;;;;AAV1D,AAWGjM,AAAWgM,AAAYC;;;;;AAlBlC,AAAAzP,AAAAqP,AAAA,AAAA,AAAO7L;AAAP,AAAAxD,AAAAqP,AAAA,AAAA,AACOC;AADP,AAAAtP,AAAAqP,AAAA,AAAA,AAEOE;AAiBDxN,AAAK,AAAA2N,AAAS7R;AAAT8R,AAAa,AAAA,AAAA,AAACjK,AAASlC;AAAvB,AAAA,AAAAkM,AAAAC,AAAAD,AAAAC,AAAC/N,AAAAA,AAAAA;;AACN0N,AAAQ,AAAC3N,AAAK,AAAKrC;AAAL,AACE,AAAAsQ,AAA4BtQ;AAA5BuQ,AAAA,AAAAxN,AAAAuN;AAAAE,AAAA,AAAArN,AAAAoN;AAAAA,AAAA,AAAAnN,AAAAmN;AAAAC,AAAOrP;AAAPqP,AAAA,AAAArN,AAAAoN;AAAAA,AAAA,AAAAnN,AAAAmN;AAAAC,AAASC;AAATD,AAAA,AAAArN,AAAAoN;AAAAA,AAAA,AAAAnN,AAAAmN;AAAAC,AAAYE;AAAZH,AAAsB9N;AAAtB,AACE,AAAArB,AAAe,AAACtB,AAAsBvB,AAAIkS;AAA1C,AAAA,AAAArP;AAAA,AAAAA,AAASvB;AAAT,AAAA,AAAA,AAAA,AAAA,AACUA,AACE6Q,AACH,AAAAC,AAAS,AAAA,AAAA,AAAA,AAACpK,AAAShI,AAAemS;AAAlCE,AACS,AAAA,AAAA,AAACxK,AAAS3D;AADnB,AAAA,AAAAkO,AAAAC,AAAAD,AAAAC,AAACtO,AAAAA,AAAAA;;;AAER,AAACpE,AAA0B,AAAA,AAAqCuS,AAAIA;;AAC1ET;AACdC,AAAQ,AAAA,AAAMA,AACJ,AAAAY,AAAStS;AAATuS,AAAa,AAAA,AAAA,AAAC1K,AAAS,AAACmH,AAAK0C;AAA7B,AAAA,AAAAY,AAAAC,AAAAD,AAAAC,AAACxO,AAAAA,AAAAA;AADH;AA7Bd,AA+BE,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAChB,AAESmB,AACGuN,AACAC;;AAGjB,AAAA,AAAAc,AAAMnG,AAAgBrM;AAAtB,AAAA,AAAAyS,AAAAD;AAAAE,AAAA,AAAAlO,AAAAiO;AAAAE,AAAA,AAAA/N,AAAA8N;AAAAA,AAAA,AAAA7N,AAAA6N;AAAAC,AAA2BC;AAA3BF,AAAsCG;AAAtCJ,AAAgDK;AAAhD,AACE,AAACC,AAAM,AAAA,AAAM/S,AACN,AAAKF;AAAL,AACE,AAAMW,AAAI,AAACC;AAAX,AACE,AAAA,AAAA,AAACsS,AAAUlT,AAAiBW,AACjB,AAAKwS;AAAL,AACE,AAAC/K,AAAO,AAAKK,AAAI6C;AAAT,AACE,AAAI,AAAC1L,AAAU6I,AAAI6C;AAGjB7C;;AACA,AAACX,AAAMW,AAAI6C,AACJ,AAAA8H,AAAM,AAAA,AAACC,AAAkB,AAAC7S,AAAO,AAAKG,AACL,AAAK2K,AACjB,AAAA,AAAA,AAAA,AAAAlL,AAAA,AAAA,AAAAA,AAAC0H,AAAM,AAACpI,AAAK4L,AACAA,AACDqB,AACE2G;AALnC,AAAA,AAAAF;;AAAAA;;;AAOXD,AACAJ;;;;AApBlC;;AAuBA,AAAA,AAAAQ,AAAAC,AAAMK;AAAN,AAAA,AAAAJ,AAAAF;AAAAE,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA3U,AAAA,AAAA2U,AAAA,AAAA,AAAA,AAAA,AAAA1U,AAAAC,AAAAyU,AAAAA;AAAAA,AAAmCvT;AAAnCF,AAAA,AAAAd,AAAAuU,AAAA;AAAAC,AAAAF;AAAAG,AAAA,AAAAjP,AAAAgP;AAAAE,AAAA,AAAA9O,AAAA6O;AAAAA,AAAA,AAAA5O,AAAA4O;AAAAC,AAAyC9Q;AAAzC6Q,AAA6CG;AAA7CJ,AAAyE5R;AAAzE,AACE,AAAMiS,AAAM,AAAA,AAAAC,AAAC9M;AAAD,AAAM,AAAI,AAAK,AAAA8M,AAAC/L,AAAQ,AAAA,AAAA,AAAC9G,AAAS,AAAA6S,AAAClP;AAAW,AAAAkP,AAACxQ;;AAAzCwQ;;AACDF;AADjB,AAEE,AAAAG,AAAA,AAAAvP,AAAa,AAAC0D,AAAO;AAAK9G,AAAEmT;AAAP,AACE,AAAI,AAAA5P,AAAS4P;AACX,AAACzP,AAAK1D,AAAE,AAACZ,AAAK+T;;AACd,AAAMC,AAAE,AAAC5P,AAAM2P;AAAME,AAAG,AAACzF,AAAKuF;AAA9B,AACE,AAACxO,AAAK3E,AAAE,AAAA,AAAAsT,AAAC1N;AAAD,AAAM,AAAA,AAAA0N,AAAKF;AAASC;;;AAJ1C,AAKWZ;AALxBG,AAAA;AAAAC,AAAA;AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAAE,AAAQK;AAAR,AAAA,AAME,AAAMI,AAAc,AAACrU,AAAOiU;AAA5B,AACE,AAAU,AAAChT,AAAsBvB,AAAI2U;AAArC;AAAA,AACE,AAAChV,AAA0B,AAAA,AAAqCgV,AAAe/S;;;AACjF,AAAMgT,AAAS,AAAA,AAACC,AAAkBN;AAC5BO,AAAW,AAACpR,AAAK6Q,AAAK,AAAA,AAAKK,AAAU,AAACvO,AAAMkO;AAC5C9T,AAAI,AAACC;AAFX,AAGE,AAAA,AAAA,AAAA,AAACqS,AAAMjT,AAAIkI,AAAsBvH,AAAa,AAACH,AAAOwU,AAAaH;;AAZzE;AAAA,AAAAZ;AAAAC;AAAAC;AAAA,AAAAC,AAAA;;;;;;;AAAA,AAAA/S,AAAA,AAAAqD,AAAAuP;AAAA,AAAA,AAAA5S;AAAA,AAAA,AAAA4S,AAAA5S;AAAA,AAAA,AAAA,AAAAgT,AAAAJ;AAAA,AAAAK,AAAA,AAAAC,AAAAN;AAAA,AAAA,AAAA,AAAAO,AAAAP;AAAAK;AAAA,AAAA/N,AAAA+N;AAAA;;;;;;;AAAA,AAAA,AAAAxP,AAAAmP,AAAQQ;AAAR,AAAA,AAME,AAAMI,AAAc,AAACrU,AAAOiU;AAA5B,AACE,AAAU,AAAChT,AAAsBvB,AAAI2U;AAArC;AAAA,AACE,AAAChV,AAA0B,AAAA,AAAqCgV,AAAe/S;;;AACjF,AAAMgT,AAAS,AAAA,AAACC,AAAkBN;AAC5BO,AAAW,AAACpR,AAAK6Q,AAAK,AAAA,AAAKK,AAAU,AAACvO,AAAMkO;AAC5C9T,AAAI,AAACC;AAFX,AAGE,AAAA,AAAA,AAAA,AAACqS,AAAMjT,AAAIkI,AAAsBvH,AAAa,AAACH,AAAOwU,AAAaH;;AAZzE;AAAA,AAAA,AAAA9P,AAAAkP;AAAA;AAAA;AAAA;;;;;;;;AAAA;;;;;;AAgBJ,AAAA,AAAAgB,AAAMI,AAAYnV;AAAlB,AAAA,AAAAgV,AAAAD;AAAAE,AAAA,AAAAzQ,AAAAwQ;AAAAE,AAAA,AAAAtQ,AAAAqQ;AAAAA,AAAA,AAAApQ,AAAAoQ;AAAAC,AAAuBE;AAAvBF,AAAA,AAAAtQ,AAAAqQ;AAAAA,AAAA,AAAApQ,AAAAoQ;AAAAC,AAA4BG;AAA5BH,AAAA,AAAAtQ,AAAAqQ;AAAAA,AAAA,AAAApQ,AAAAoQ;AAAAC,AAA0CI;AAA1CL,AAAwDM;AAAxD,AACE,AAAAC,AAA2B,AAAI,AAACzN,AAAKuN,AAAaA,AACnB,AAACzN,AAAKyN,AAAYC;AADjDE,AAAA,AAAAjR,AAAAgR;AAAAE,AAAA,AAAA9Q,AAAA6Q;AAAAA,AAAA,AAAA5Q,AAAA4Q;AAAAC,AAAOJ;AAAPG,AAAqBF;AAEfF,AAAc,AAACtR,AAAAA,AAAAA,AAAQ/D,AAAAA,AAAIqV,AAAAA;AAC3BA,AAAc,AAACM,AACAN,AACA,AAAKxT;AAAL,AACE,AAAAgB,AAAW,AAAA,AAAMhB;AAAjB,AAAA,AAAAgB;AAAA,AAAAA,AAASN;AAAT,AACE,AAAMjB,AAAM,AAAAT,AAAI,AAACU,AAAsBvB,AAAIuC;AAA/B,AAAA,AAAA1B;AAAAA;;AACI,AAAClB,AACA,AAAA,AAAqC4C,AAAGA;;;AAFzD,AAGE,AAAA,AAACqF,AAAM/F,AAAaP;;AACtBO;;;AACnByT,AAAY,AAAC9U,AAAK8U;AAClBC,AAAK,AAAC5R,AAAiB3D,AAAIuV;AAbjC,AAAAhR,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAcMrB,AAIoBgS,AAAeC,AAAaC;AAlBtD,AAmBE,AAAC5L,AAAetG;;AAEpB,AAAA,AAAAuS,AAAMI,AAAahW;AAAnB,AAAA,AAAA6V,AAAAD;AAAAE,AAAA,AAAAtR,AAAAqR;AAAAE,AAAA,AAAAnR,AAAAkR;AAAAA,AAAA,AAAAjR,AAAAiR;AAAAC,AAAwBE;AAAxBF,AAAA,AAAAnR,AAAAkR;AAAAA,AAAA,AAAAjR,AAAAiR;AAAAC,AAAoCG;AAApCJ,AAA0CP;AAA1C,AACE,AAACJ,AAAWnV,AAAI,AAAA0E,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAASwR,AAAI,AAACrO,AAAK,AAACvH,AAAO,AAAA,AAACoD,AAAK,AAAClD,AAAKyV,AAAiBV;;AAE1E,AAAA,AAAAY,AAAMI,AAAYvW;AAAlB,AAAA,AAAAoW,AAAAD;AAAAE,AAAA,AAAA7R,AAAA4R;AAAAE,AAAA,AAAA1R,AAAAyR;AAAAA,AAAA,AAAAxR,AAAAwR;AAAAC,AAAuBE;AAAvBF,AAAA,AAAA1R,AAAAyR;AAAAA,AAAA,AAAAxR,AAAAwR;AAAAC,AAA4BG;AAA5BJ,AAAwCd;AAAxC,AACE,AAAA1S,AACoD,AAACgU,AAA2B7W,AAAIyW;AADpF,AAAA,AAAA5T;AAAA,AAAA6T,AAAA7T;AAAA6T,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA9X,AAAA,AAAA8X,AAAA,AAAA,AAAA,AAAA,AAAA7X,AAAAC,AAAA4X,AAAAA;AAAAA,AAC4CE;AAD5CD,AAAA,AAAA3X,AAAA0X,AAAA;AAAA,AAEE,AAAMnB,AAAK,AAAC5R,AAAiB3D,AAAIuV;AAAjC,AACE,AAAC5L,AAAe,AAAAjF,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAA+BiS,AAAapB;;AAC9D,AAAC5V,AAA0B,AAAA,AAAqC8W,AAAWA;;;AAE/E,AAAA,AAAAK,AAAMI,AAAoBlX;AAA1B,AAAA,AAAA+W,AAAAD;AAAAE,AAAA,AAAAxS,AAAAuS;AAAAE,AAAA,AAAArS,AAAAoS;AAAAA,AAAA,AAAAnS,AAAAmS;AAAAC,AAA+BE;AAA/BH,AAAiDzB;AAAjD,AACE,AAGM6B,AAAiB,AAAC5W,AAAK2W;AACvBV,AAAU,AAAC1T,AAAU,AAACzC,AAAO,AAAA,AAACoD,AAAK0T,AACA,AAAA,AAAK,AAAOA,AACnC,AAAC5X,AAAK2X;AANxB,AAOE,AAACZ,AAAWvW,AAAI,AAAC+C,AAAU,AAAA,AAAA,AAACsU,AAAWZ,AAAUlB,AAC/B,AAAC/V,AAAK2X;;AAM5B,AAAA,AAAAG,AAAMI,AAAiB1X;AAAvB,AAAA,AAAAuX,AAAAD;AAAAE,AAAA,AAAAhT,AAAA+S;AAAAE,AAAA,AAAA7S,AAAA4S;AAAAA,AAAA,AAAA3S,AAAA2S;AAAAC,AAA4BE;AAA5BF,AAAA,AAAA7S,AAAA4S;AAAAA,AAAA,AAAA3S,AAAA2S;AAAAC,AAAgCG;AAAhCJ,AAA0CvO;AAA1C,AACE,AAAA4O,AACM,AAAME,AAAM,AAACnT,AAAMqE;AAAnB,AACE,AAAI,AAAS8O;AAAb,AACGA,AAAM,AAAClT,AAAKoE;;AADf,AAAA,AAEOA;;;AAJf,AAAA9G,AAAA0V,AAAA,AAAA,AAAOtL;AAAP,AAAApK,AAAA0V,AAAA,AAAA,AAAiB5O;AAAjB6O,AAOM,AAAMjW,AAAE,AAAC+C,AAAMqE;AAAf,AACE,AAAI,AAACrC,AAAK/E;AAAV,AACGA,AAAE,AAACgD,AAAKoE;;AADX,AAAA,AAEOA;;;AAVf,AAAA9G,AAAA2V,AAAA,AAAA,AAMOE;AANP,AAAA7V,AAAA2V,AAAA,AAAA,AAMgB7O;AAKV+O,AAAS,AAAIzL,AACF,AAAA,AAAC3E,AAAMoQ,AAAczL,AACrByL;AAbjB,AAcE,AAACC,AAAejY,AAAI4X,AAAQI;;AAC5B,AAAO/O,AAAMA;AAAb,AACOgI;;AADP,AAIE,AAAIhI;AACF,AAAAiP,AAAiB,AAACtT,AAAMqE;AAAxBkP,AAAA,AAAA3T,AAAA0T;AAAAE,AAAA,AAAAxT,AAAAuT;AAAAA,AAAA,AAAAtT,AAAAsT;AAAAC,AAAOhW;AAAP+V,AAAW5C;AAAX,AACE,AAAA8C,AAAMjW;AAANiW,AAAA,AAAA,AAAAA,AAAAC,AAAA,AAAAD,AAAA;AAAA,AAAA,AAAAA;AAAA;AACW,AAAO,AAACxT,AAAKoE;AACN,AAACnE,AAAKmM,AACA,AAACtH,AACA,AAAA,AAAA,AAAC0N,AAAe9B;;;;;;AAJzC;AAKU,AAEE,AAAA,AAAAhR,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAACiP,AAAU3T,AAAiBuV;;AAC5B,AAAO,AAAC1Q,AAAKoE;AAAOgI;;;;;;AARhC;AASiB,AAAO,AAACpM,AAAKoE;AACN,AAACnE,AAAKmM,AACA,AAACtH,AACA,AAAA,AAAA,AAAA,AAAA,AAAC0N,AAA2B9B;;;;;;AAZ3D;AAcE,AAAO,AAAC1Q,AAAKoE;AAAOgI;;;;;;;AAdtB,AAAA,AAAA9N,AAAA,AAAA,AAAAkV;;;;AAeF,AAAC1O,AAAe,AAAA,AAAA,AAAC0N,AAAUpG;;;;;AAOnC,AAAA,AAAAsH,AAAME,AAAazY;AAAnB,AAAA,AAAAwY,AAAAD;AAAA,AAAApW,AAAAqW,AAAA,AAAA,AAAwB5V;AAAxB,AAAAT,AAAAqW,AAAA,AAAA,AAA0BxM;AAA1B,AACE,AAAC5I,AAAe,AAAA,AAAA,AAACwE,AAAM5H,AAAkCgM;;AAE3D,AAAA,AAAA0M,AAAME,AAAc5Y;AAApB,AAAA,AAAA2Y,AAAAD;AAAA,AAAAvW,AAAAwW,AAAA,AAAA,AAAyB/V;AAAzB,AAAAT,AAAAwW,AAAA,AAAA,AAA2BzC;AAA3B,AAAA/T,AAAAwW,AAAA,AAAA,AAA+BvX;AAA/B,AACE,AAAM8U,AAAI,AAACnS,AAAAA,AAAAA,AAAQ/D,AAAAA,AAAIkW,AAAAA;AACjB9U,AAAE,AAAC2C,AAAAA,AAAAA,AAAQ/D,AAAAA,AAAIoB,AAAAA;AACf8U,AAAI,AAAC2C,AAAa3C;AAFxB,AAGE,AAACvM,AAAe,AAAAjF,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAYwR,AAAI9U;;AAMpC,AAAA,AAAM0X,AAAQ/K;AAAd,AACE,AAAA5M,AAAa,AAAC3B,AAAKuO;AAAnB,AAAA,AAAA5M;AAAA,AAAA,AAAAA,AAAWU;AAAX,AACE,AAAA,AAAYA;;AADd;;;AAKF,AAAA,AAAMkX,AAAc/Y,AAAI4B;AAAxB,AACE,AAAMmM,AAAE,AAACnJ,AAAMhD;AAAf,AACE,AAAI,AAAA+C,AAASoJ;AACX,AAEMiL,AAAY,AAACha,AAAIR,AAAauP;AAC9BnL,AAAE,AAAA,AAAA,AAAMoW,AAAY,AAAC9Z,AAAkBc,AAAIgZ,AAAYjL;AACvDA,AAAE,AAAAlN,AAAImY;AAAJ,AAAA,AAAAnY;AAAAA;;AACI,AAAA,AAACuC,AAAepD,AAAI+N;;;AAC1BA,AAAE,AAAI,AAAK,AAACkL,AAAUlL,AACX,AAAAlN,AACC,AAACqY,AAAanL;AADf,AAAA,AAAAlN;AAAAA;;AAEC,AAAA,AAAA,AAAIkN,AAAEvO;;AAHhB,AAAAU,AAAI,AAID6N,AAAEA;AAVb,AAWE,AAAI,AAAK,AAACjL,AAAI,AAACqW,AAAMpL,AACZ,AAAAlN,AACCmY;AADD,AAAA,AAAAnY;AAAAA;;AAEC,AAACnB,AAAUjB,AAAOsP;;AAHxB;AAIF,AAAAqL,AAAMrL;AAAN,AAAA,AAAA,AAAA9M,AAAA,AAAA,AAAAmY;AAgCI,AAACjE,AAAWnV,AAAI4B;;AAhCpB,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AAmCS,AAACzF,AAAU3T,AAAI4B;;AAnCxB,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AA4BO,AAACrJ,AAAY/P,AAAI4B;;AA5BxB,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AAQW,AAAA,AAAC3R,AAAUzH,AAAI4B;;AAR1B,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AA2BK,AAACxJ,AAAU5P,AAAI4B;;AA3BpB,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AAWkB,AAAMnI,AAAI,AAACjE,AAAYhN,AAAI4B;AAA3B,AACEqP;;AAZpB,AAAA,AAAAhQ,AAAA,AAAA,AAAAmY;AAWkB,AAAMnI,AAAI,AAACjE,AAAYhN,AAAI4B;AAA3B,AACEqP;;AAZpB,AAAA,AAAAhQ,AAAA,AAAA,AAAAmY;AAmBU,AAACC,AAAerZ,AAAI4B;;AAnB9B,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AAKK,AAACzP,AAAe,AAAA,AAAA,AAAC9B,AACK,AAAClE,AAAiB3D,AAAI,AAACgP,AAAKpN;;AANvD,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AAoBO,AAACzK,AAAY3O,AAAI4B;;AApBxB,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AA0BQ,AAAAG,AAASvZ;AAATwZ,AAAa,AAACC,AAAazZ,AAAI4B;AAA/B,AAAA,AAAA2X,AAAAC,AAAAD,AAAAC,AAACzV,AAAAA,AAAAA;;AA1BT,AAAA,AAAA9C,AAAA,AAAA,AAAAmY;AAiCqB,AAAClC,AAAmBlX,AAAI4B;;AAjC7C,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AASM,AAACtN,AAAW9L,AAAI4B;;AATtB,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AA8BU,AAAC/M,AAAerM,AAAI4B;;AA9B9B,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AAiBQ,AAAA;AAAQ,AAAC9V,AAAO1B;;AAjBxB,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AA+Bc,AAACpD,AAAYhW,AAAI4B;;AA/B/B,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AAoCK,AAAC1B,AAAgB1X,AAAI4B;;AApC1B,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AAsBM,AAAM/V,AAAI,AAACiW,AAAWtZ,AAAI4B;AAA1B,AACE,AAAI,AAAA,AAA0B5B;AAC5BqD;;AACA,AAACU,AAAAA,AAAAA,AAAQ/D,AAAAA,AAAIqD,AAAAA;;;AAzBvB,AAAA,AAAApC,AAAA,AAAA,AAAAmY;AAOM,AAACpP,AAAWhK,AAAI4B;;AAPtB,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AAQW,AAAA,AAAC3R,AAAUzH,AAAI4B;;AAR1B,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AAsCO,AAACR,AAAa5Y,AAAI4B;;AAtCzB,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AAkCM,AAAC7C,AAAWvW,AAAI4B;;AAlCtB,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AAcK,AAAC5O,AAASxK,AAAI,AAACgP,AAAKpN;;AAdzB,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AAqCM,AAACX,AAAYzY,AAAI4B;;AArCvB,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AAgBO,AAAClO,AAAYlL,AAAI4B;;AAhBxB,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AAqBW,AAAC/J,AAAgBrP,AAAI4B;;AArBhC,AAAA,AAAAX,AAAA,AAAA,AAAAmY;AA6BM,AAAC9H,AAAWtR,AAAI4B;;AA7BtB,AA0CE,AAAC+H,AAAe,AAAC9B,AAAKkG,AAAE,AAACpK,AAAiB3D,AAAI,AAACgP,AAAKpN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACtD,AAAA,AACE,AAAI,AAACkX,AAAO/K;AACV,AAAM4L,AAAW,AAAAC,AAAA;AAAAC,AACe,AAAA,AAAc,AAACra,AAAKuO;AADnC,AAAA,AAAA6L,AAAAC,AAAAD,AAAAC,AAACta,AAAAA,AAAAA;;AAEZ6B,AAAE,AAAIuY,AACF,AAAC9a,AAAMkP,AAAEnM,AACF,AAAA,AAAW5B,AACXA,AACA,AAACgP,AAAKpN,AACb,AAAC/C,AAAMkP,AAAEnM,AACF,AAAA,AAAW5B,AAAK,AAACgP,AAAKpN;AACjC+I,AAAS,AAAI,AAAA,AAA0B3K,AAC5BoB,AACA,AAAC2C,AAAAA,AAAAA,AAAQ/D,AAAAA,AAAIoB,AAAAA;AAX9B,AAYEuJ;;AACF,AAAChB,AAAe,AAAC9B,AAAKkG,AAAE,AAACpK,AAAiB3D,AAAI,AAACgP,AAAKpN;;AAfxD,AAAA,AAAA8X,AAgBiCvW;AAhBjC,AAAAuW,AAgB2C/S;AAhB3C,AAiBI,AAACmT,AAA8B9Z,AAAI2G,AAAE/E;;AAjBzC,AAAA,AAAA8X;;;;;AAkBJ,AAAMzI,AAAI,AAACtH,AAAe,AAAChG,AAAiB3D,AAAI4B;AAAhD,AACEqP;;;AAER,AAAA,AAAMlN,AACH/D,AAAI4B;AADP,AAGE,AAAMqP,AAAI,AAAA,AAAM,AAAC8I,AAAUnY,AAAMA,AACjB,AAAA+C,AAAS/C,AAAM,AAAMR,AAAE,AAAA,AAACgC,AAAepD,AAAI4B;AAA5B,AACE,AAAM,AAACmY,AAAU3Y;AAAGA;;AAApB,AAEM,AAAC6X,AAAU7X;AAAG,AAAI,AAAA,AAAQ,AAAC5B,AAAK4B;AAAlB,AAAAlB,AACGkB;;AAAE,AAAC4Y,AAAgB5Y;;;AAH1C,AAIY,AAAC6Y,AAAW7Y,AAAE,AAAC5B,AAAKoC;;;;AANvD,AAQM,AAACqY,AACA,AAAA,AAAA,AAAA,AACE,AAACrT,AAAKhF,AACN,AAAI,AAACuF,AAAO,AAACxD,AAAiB3D,AAAI,AAACka,AAAKtY,AAC5B,AAAC+B,AAAiB3D,AAAI,AAACma,AAAKvY,AACpCwY,AACJ,AAAI,AAACvU,AAAQjE,AAAM,AAACyY,AAAKzY,AACzB,AAAI,AAACmE,AAAK,AAACuU,AAAM1Y,AAAM,AAAC+B,AAAiB3D,AAAI4B,AACzCwY,AACJ,AAAK,AAACrS,AAAKnG,AAAM,AAAC4C,AAAI5C,AACtB,AAACmX,AAAa/Y,AAAI4B,AACZA;AACR,AAAA,AAAA,AAAA,AAAA,AAAC2Y,AAAY,AAAC/a,AAAKoC;;AApBpC,AAuBEqP;;AAIJ","names":["sci.impl.analyzer/special-syms","sci.impl.analyzer/macros","p__77699","map__77700","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","allow","cljs.core.get","deny","sci.impl.analyzer/check-permission!","check-sym","sym","G__77704","G__77705","sci.impl.utils/kw-identical?","cljs.core/meta","sci.impl.utils/strip-core-ns","cljs.core/contains?","sci.impl.utils.throw_error_with_location","p__77717","map__77718","env","sci.impl.analyzer/lookup*","ctx","call?","cljs.core/deref","sym-ns","G__77724","cljs.core/namespace","cljs.core.symbol","sym-name","cljs.core/name","cnn","sci.impl.vars/current-ns-name","the-current-ns","G__77727","or__4126__auto__","cljs.core.get_in","cljs.core/find","and__4115__auto__","cljs.core._EQ_","G__77735","temp__5735__auto__","v","G__77747","clazz","sci.impl.interop/resolve-class","G__77763","c","sci.impl.analyzer/tag","_ctx","expr","m","p__77775","map__77776","bindings","sci.impl.analyzer/lookup","vec__77780","cljs.core.nth","k","kv","vec__77789","t","sci.impl.utils/mark-resolve-sym","cljs.core.vary_meta","cljs.core/assoc","vec__77795","_","temp__5733__auto__","cljs.core/not","cljs.core/with-meta","var_args","G__77813","sci.impl.analyzer/resolve-symbol","js/Error","sci.impl.analyzer.resolve_symbol","res","cljs.core/second","n","clojure.string/starts-with?","clojure.string/ends-with?","cljs.core.subs","sci.impl.analyzer/analyze-children","children","p1__77838#","cljs.core.mapv","sci.impl.analyzer/analyze","sci.impl.analyzer/maybe-destructured","params","body","cljs.core/every?","cljs.core/symbol?","new-params","lets","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","cljs.core/Symbol","cljs.core/first","cljs.core/next","cljs.core.conj","gparam","cljs.core.gensym","p__77876","p__77877","map__77878","fn-expr","vec__77879","seq__77880","first__77881","sci.impl.analyzer/expand-fn-args+body","fn-name","binding-vector","body-exprs","macro?","cljs.core/vector?","map__77885","cljs.core.into","fixed-args","p1__77862#","cljs.core.take_while","cljs.core.not_EQ_","fixed-arity","cljs.core/count","var-arg-name","p1__77863#","cljs.core.drop_while","next-body","conds","e","cljs.core/map?","pre","post","cljs.core/vec","cljs.core.map","cljs.core.update","cljs.core/merge","cljs.core/zipmap","cljs.core.repeat","p__77899","vec__77902","seq__77903","first__77904","sci.impl.analyzer/expand-fn","_fn","name?","cljs.core.assoc","cljs.core/cons","bodies","cljs.core/seq?","cljs.core/assoc-in","analyzed-bodies","cljs.core.reduce","p__77906","map__77907","max-fixed","min-varargs","acc","arglist","new-min-varargs","x__4214__auto__","y__4215__auto__","cljs.core/conj","arities","arglists","sci.impl.analyzer/expand-let*","destructured-let-bindings","exprs","vec__77914","new-let-bindings","p__77917","p__77918","vec__77919","vec__77922","binding-name","binding-value","cljs.core.partition","sci.impl.utils/mark-eval-call","p__77926","vec__77927","seq__77928","first__77929","sci.impl.analyzer/expand-let","_let","let-bindings","sci.impl.destructure/destructure","p__77934","vec__77936","seq__77937","first__77938","sci.impl.analyzer/expand->","x","forms","expanded","form","threaded","p__77946","vec__77947","seq__77948","first__77949","sci.impl.analyzer/expand-as->","_as","name","vec__77953","seq__77954","first__77955","cljs.core.interleave","cljs.core/butlast","cljs.core/empty?","cljs.core/last","p__77967","vec__77968","sci.impl.analyzer/expand-def","_def","var-name","?docstring","?init","G__77976","G__77977","sci.impl.analyzer/expand-declare","cljs.core/simple-symbol?","docstring","init","sci.impl.vars/current-ns","G__77980","G__77981","p__77984","vec__77986","seq__77987","first__77988","sci.impl.analyzer/expand-defn","op","G__77990","G__77991","vec__77993","pre-body","cljs.core/split-with","cljs.core.comp","cljs.core/sequential?","ds","meta-map","G__78002","G__78003","cljs.core.merge","fn-body","f","G__78004","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","sci.impl.analyzer/expand-comment","seq78008","G__78009","self__4723__auto__","_body","sci.impl.analyzer/expand-loop","bv","arg-names","cljs.core.take_nth","init-vals","cljs.core/rest","cljs.core/nnext","G__78015","G__78016","cljs.core/list","sci.impl.analyzer/expand-lazy-seq","G__78024","G__78025","p__78031","vec__78032","seq__78033","first__78034","sci.impl.analyzer/expand-if","_if","G__78035","sci.impl.analyzer/expand-case","G__78048","G__78049","clauses","match-clauses","result-clauses","default","cljs.core/odd?","G__78052","G__78053","cases","assoc-new","case-map","ret-map","vec__78070","seq__78071","first__78072","cljs.core/list?","ret","p__78078","vec__78079","seq__78080","first__78081","sci.impl.analyzer/expand-try","_try","vec__78085","catches","finally","catch-exprs","finally-expr","G__78102","G__78103","vec__78106","seq__78107","first__78108","ex","binding","G__78113","G__78114","G__78117","G__78118","p__78123","vec__78124","seq__78125","first__78126","_declare","names","_expr","cljs.core.swap_BANG_","cljs.core.update_in","current-ns","G__78135","sci.impl.vars/->SciVar","sci.impl.vars/current-file","p__78143","p__78144","map__78145","vec__78146","seq__78147","first__78148","sci.impl.analyzer/do-import","import-symbols-or-lists","specs","p1__78140#","seq__78155","chunk__78156","count__78157","i__78158","cljs.core/chunked-seq?","c__4556__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","spec","p","cs","p1__78141#","fq-class-name","last-dot","clojure.string.last_index_of","class-name","p__78179","vec__78180","seq__78181","first__78182","sci.impl.analyzer/expand-dot","_dot","instance-expr","method-expr","args","vec__78186","seq__78187","first__78188","sci.impl.utils/vary-meta*","p__78191","vec__78193","seq__78194","first__78195","sci.impl.analyzer/expand-dot*","method-name","obj","p__78196","vec__78197","seq__78198","first__78199","sci.impl.analyzer/expand-new","_new","class-sym","map__78200","constructor","_opts","sci.impl.interop/resolve-class-opts","p__78204","vec__78205","seq__78206","first__78207","sci.impl.analyzer/expand-constructor","constructor-sym","constructor-name","cljs.core.list_STAR_","p__78213","vec__78214","seq__78215","first__78216","sci.impl.analyzer/analyze-ns-form","_ns","ns-name","vec__78219","vec__78222","fexpr","attr-map","sci.impl.utils/set-namespace!","vec__78242","seq__78243","first__78244","G__78246","cljs.core/Keyword","p__78255","vec__78257","sci.impl.analyzer/analyze-var","p__78263","vec__78264","sci.impl.analyzer/analyze-set!","sci.impl.types/getVal","sci.impl.analyzer/macro?","sci.impl.analyzer/analyze-call","special-sym","sci.impl.vars/var?","sci.impl.vars/isMacro","sci.impl.utils/eval?","G__78284","sci.impl.analyzer.expand_comment","sci.impl.for-macro/expand-for","G__78289","G__78290","sci.impl.doseq-macro/expand-doseq","e78306","needs-ctx?","G__78307","G__78308","sci.impl.utils/rethrow-with-location-of-node","sci.impl.utils/constant?","sci.impl.types/->EvalVar","sci.impl.utils/merge-meta","cljs.core/keys","cljs.core/vals","sci.impl.utils/mark-eval","cljs.core/set?","cljs.core/empty","cljs.core/select-keys"],"sourcesContent":["(ns sci.impl.analyzer\n  {:no-doc true}\n  (:refer-clojure :exclude [destructure macroexpand macroexpand-all macroexpand-1])\n  (:require\n   [clojure.string :as str]\n   [sci.impl.destructure :refer [destructure]]\n   [sci.impl.doseq-macro :refer [expand-doseq]]\n   [sci.impl.for-macro :refer [expand-for]]\n   [sci.impl.interop :as interop]\n   [sci.impl.types :as types]\n   [sci.impl.utils :as utils :refer\n    [eval? mark-resolve-sym mark-eval mark-eval-call constant?\n     rethrow-with-location-of-node throw-error-with-location\n     merge-meta kw-identical? strip-core-ns set-namespace!]]\n   [sci.impl.vars :as vars]))\n\n;; derived from (keys (. clojure.lang.Compiler specials))\n;; (& monitor-exit case* try reify* finally loop* do letfn* if clojure.core/import* new deftype* let* fn* recur set! . var quote catch throw monitor-enter def)\n(def special-syms '#{try finally do if new recur quote catch throw def . var set!})\n\n;; Built-in macros.\n\n(def macros '#{do if and or -> as-> quote quote* let fn fn* def defn\n               comment loop lazy-seq for doseq case try defmacro\n               declare expand-dot* expand-constructor new . import in-ns ns var\n               set! resolve macroexpand-1 macroexpand the-ns})\n\n(defn check-permission! [{:keys [:allow :deny]} check-sym sym]\n  (when-not (kw-identical? :allow (-> sym meta :line))\n    (let [check-sym (strip-core-ns check-sym)]\n      (when-not (if allow (contains? allow check-sym)\n                    true)\n        (throw-error-with-location (str sym \" is not allowed!\") sym))\n      (when (if deny (contains? deny check-sym)\n                false)\n        (throw-error-with-location (str sym \" is not allowed!\") sym)))))\n\n(defn lookup* [{:keys [:env] :as ctx} sym call?]\n  (let [sym-ns (some-> (namespace sym) symbol)\n        sym-name (symbol (name sym))\n        env @env\n        cnn (vars/current-ns-name)\n        the-current-ns (-> env :namespaces cnn)\n        ;; resolve alias\n        sym-ns (when sym-ns (or (get-in the-current-ns [:aliases sym-ns])\n                                sym-ns))]\n    (or (find the-current-ns sym) ;; env can contain foo/bar symbols from bindings\n        (cond\n          (and sym-ns (or (= sym-ns 'clojure.core) (= sym-ns 'cljs.core)))\n          (or (some-> env :namespaces (get 'clojure.core) (find sym-name))\n              (when-let [v (when call? (get macros sym-name))]\n                [sym v]))\n          sym-ns\n          (or (some-> env :namespaces sym-ns (find sym-name))\n              (when-let [clazz (interop/resolve-class ctx sym-ns)]\n                [sym ^{:sci.impl/op :static-access} [clazz sym-name]]))\n          :else\n          ;; no sym-ns, this could be a symbol from clojure.core\n          (when-not (contains?\n                     (get-in the-current-ns [:refer 'clojure.core :exclude]) sym-name)\n            (or\n             (some-> env :namespaces (get 'clojure.core) (find sym-name))\n             (when (when call? (get macros sym))\n               [sym sym])\n             (when-let [c (interop/resolve-class ctx sym)]\n               [sym c])))))))\n\n(defn tag [_ctx expr]\n  (when-let [m (meta expr)]\n    (:tag m)))\n\n(defn lookup [{:keys [:bindings] :as ctx} sym call?]\n  (let [[k v :as kv]\n        (or\n         ;; bindings are not checked for permissions\n         (when-let [[k v]\n                    (find bindings sym)]\n           ;; never inline a binding at macro time!\n           (let [t (tag ctx v)\n                 v (mark-resolve-sym k)\n                 ;; pass along tag of expression!\n                 v (if t (vary-meta v\n                                    assoc :tag t)\n                       v)]\n             [k v]))\n         (when-let\n             [[k _ :as kv]\n              (or\n               (lookup* ctx sym call?)\n               #_(when (= 'recur sym)\n                   [sym sym]))]\n           (check-permission! ctx k sym)\n           kv))]\n    ;; (prn 'lookup sym '-> res)\n    (if-let [m (and (not (:sci.impl/prevent-deref ctx))\n                    (meta k))]\n      (if (:sci.impl/deref! m)\n        ;; the evaluation of this expression has been delayed by\n        ;; the caller and now is the time to deref it\n        [k (with-meta [v]\n             {:sci.impl/op :deref!})]\n        kv)\n      kv)))\n\n(defn resolve-symbol\n  ([ctx sym] (resolve-symbol ctx sym false))\n  ([ctx sym call?]\n   (let [sym sym ;; (strip-core-ns sym)\n         res (second\n              (or\n               (lookup ctx sym call?)\n               ;; TODO: check if symbol is in macros and then emit an error: cannot take\n               ;; the value of a macro\n               (let [n (name sym)]\n                 (cond\n                   (and call?\n                        (str/starts-with? n \".\")\n                        (> (count n) 1))\n                   [sym 'expand-dot*] ;; method invocation\n                   (and call?\n                        (str/ends-with? n \".\")\n                        (> (count n) 1))\n                   [sym 'expand-constructor]\n                   (str/starts-with? n \"'\") ;; TODO: deprecated?\n                   (let [v (symbol (subs n 1))]\n                     [v v])\n                   :else (throw-error-with-location\n                          (str \"Could not resolve symbol: \" (str sym))\n                          sym)))))]\n     ;; (prn 'resolve sym '-> res (meta res))\n     res)))\n\n(declare analyze)\n\n(defn analyze-children [ctx children]\n  (mapv #(analyze ctx %) children))\n\n(defn maybe-destructured\n  [params body]\n  (if (every? symbol? params)\n    {:params params\n     :body body}\n    (loop [params params\n           new-params (with-meta [] (meta params))\n           lets []]\n      (if params\n        (if (symbol? (first params))\n          (recur (next params) (conj new-params (first params)) lets)\n          (let [gparam (gensym \"p__\")]\n            (recur (next params) (conj new-params gparam)\n                   (-> lets (conj (first params)) (conj gparam)))))\n        {:params new-params\n         :body [`(let ~lets\n                   ~@body)]}))))\n\n(defn expand-fn-args+body [{:keys [:fn-expr] :as ctx} fn-name [binding-vector & body-exprs] macro?]\n  (when-not binding-vector\n    (throw-error-with-location \"Parameter declaration missing.\" fn-expr))\n  (when-not (vector? binding-vector)\n    (throw-error-with-location \"Parameter declaration should be a vector\" fn-expr))\n  (let [binding-vector (if macro? (into ['&form '&env] binding-vector)\n                           binding-vector)\n        fixed-args (take-while #(not= '& %) binding-vector)\n        fixed-arity (count fixed-args)\n        var-arg-name (second (drop-while #(not= '& %) binding-vector))\n        next-body (next body-exprs)\n        conds (when next-body\n                (let [e (first body-exprs)]\n                  (when (map? e) e)))\n        body-exprs (if conds next-body body-exprs)\n        conds (or conds (meta binding-vector))\n        pre (:pre conds)\n        post (:post conds)\n        body-exprs (if post\n                     `((let [~'% ~(if (< 1 (count body-exprs))\n                                    `(do ~@body-exprs)\n                                    (first body-exprs))]\n                         ~@(map (fn* [c] `(assert ~c)) post)\n                         ~'%))\n                     body-exprs)\n        body-exprs (if pre\n                     (concat (map (fn* [c] `(assert ~c)) pre)\n                             body-exprs)\n                     body-exprs)\n        {:keys [:params :body]} (maybe-destructured binding-vector body-exprs)\n        ctx (update ctx :bindings merge (zipmap params\n                                                (repeat nil)))\n        body (analyze-children ctx body)]\n    #:sci.impl{:body body\n               :params params\n               :fixed-arity fixed-arity\n               :var-arg-name var-arg-name\n               :fn-name fn-name}))\n\n(defn expand-fn [ctx [_fn name? & body :as fn-expr] macro?]\n  (let [ctx (assoc ctx :fn-expr fn-expr)\n        fn-name (if (symbol? name?)\n                  name?\n                  nil)\n        body (if fn-name\n               body\n               (cons name? body))\n        ;; fn-name (or fn-name (gensym* \"fn\"))\n        bodies (if (seq? (first body))\n                 body\n                 [body])\n        ctx (if fn-name (assoc-in ctx [:bindings fn-name] nil)\n                ctx)\n        analyzed-bodies (reduce\n                         (fn [{:keys [:max-fixed :min-varargs] :as acc} body]\n                           (let [arglist (first body)\n                                 body (expand-fn-args+body ctx fn-name body macro?)\n                                 body (assoc body :sci.impl/arglist arglist)\n                                 var-arg-name (:sci.impl/var-arg-name body)\n                                 fixed-arity (:sci.impl/fixed-arity body)\n                                 new-min-varargs (when var-arg-name fixed-arity)]\n                             (when (and var-arg-name min-varargs)\n                               (throw-error-with-location \"Can't have more than 1 variadic overload\" fn-expr))\n                             (when (and (not var-arg-name) min-varargs (> fixed-arity min-varargs))\n                               (throw-error-with-location\n                                \"Can't have fixed arity function with more params than variadic function\" fn-expr))\n                             (-> acc\n                                 (assoc :min-varargs new-min-varargs\n                                        :max-fixed (max (:sci.impl/fixed-arity body)\n                                                        max-fixed))\n                                 (update :bodies conj body)\n                                 (update :arglists conj arglist))))\n                         {:bodies []\n                          :arglists []\n                          :min-var-args nil\n                          :max-fixed -1} bodies)\n        arities (:bodies analyzed-bodies)\n        arglists (:arglists analyzed-bodies)]\n    (with-meta #:sci.impl{:fn-bodies arities\n                          :fn-name fn-name\n                          :arglists arglists\n                          :fn true}\n      {:sci.impl/op :fn})))\n\n(defn expand-let*\n  [ctx destructured-let-bindings exprs]\n  (let [[ctx new-let-bindings]\n        (reduce\n         (fn [[ctx new-let-bindings] [binding-name binding-value]]\n           (let [v (analyze ctx binding-value)]\n             [(update ctx :bindings assoc binding-name v)\n              (conj new-let-bindings binding-name v)]))\n         [ctx []]\n         (partition 2 destructured-let-bindings))]\n    (mark-eval-call `(~'let ~new-let-bindings ~@(analyze-children ctx exprs)))))\n\n(defn expand-let\n  \"The let macro from clojure.core\"\n  [ctx [_let let-bindings  & exprs]]\n  (let [let-bindings (destructure let-bindings)]\n    (expand-let* ctx let-bindings exprs)))\n\n(defn expand->\n  \"The -> macro from clojure.core.\"\n  [ctx [x & forms]]\n  (let [expanded\n        (loop [x x, forms forms]\n          (if forms\n            (let [form (first forms)\n                  threaded (if (seq? form)\n                             (with-meta (concat (list (first form) x)\n                                                (next form))\n                               (meta form))\n                             (list form x))]\n              (recur threaded (next forms))) x))]\n    (analyze ctx expanded)))\n\n(defn expand-as->\n  \"The ->> macro from clojure.core.\"\n  [ctx [_as expr name & forms]]\n  (let [[let-bindings & body] `([~name ~expr\n                                 ~@(interleave (repeat name) (butlast forms))]\n                                ~(if (empty? forms)\n                                   name\n                                   (last forms)))]\n    (expand-let* ctx let-bindings body)))\n\n(declare expand-declare)\n\n(defn expand-def\n  [ctx [_def var-name ?docstring ?init :as expr]]\n  (expand-declare ctx [nil var-name])\n  (when-not (simple-symbol? var-name)\n    (throw-error-with-location \"Var name should be simple symbol.\" expr))\n  (let [docstring (when ?init ?docstring)\n        init (if docstring ?init ?docstring)\n        init (if (= (count expr) 2)\n               :sci.impl/var.unbound\n               (analyze ctx init))\n        m (meta var-name)\n        m (analyze ctx m)\n        m (assoc m :ns @vars/current-ns)\n        m (if docstring (assoc m :doc docstring) m)\n        var-name (with-meta var-name m)]\n    (expand-declare ctx [nil var-name])\n    (mark-eval-call (list 'def var-name init))))\n\n(defn expand-defn [ctx [op fn-name & body :as expr]]\n  (when-not (simple-symbol? fn-name)\n    (throw-error-with-location \"Var name should be simple symbol.\" expr))\n  (expand-declare ctx [nil fn-name])\n  (let [macro? (= \"defmacro\" (name op))\n        [pre-body body] (split-with (comp not sequential?) body)\n        _ (when (empty? body)\n            (throw-error-with-location \"Parameter declaration missing.\" expr))\n        docstring (when-let [ds (first pre-body)]\n                    (when (string? ds) ds))\n        meta-map (when-let [m (last pre-body)]\n                   (when (map? m) m))\n        meta-map (analyze ctx (merge (meta expr) meta-map))\n        fn-body (with-meta (cons 'fn body)\n                  (meta expr))\n        f (expand-fn ctx fn-body macro?)\n        arglists (seq (:sci.impl/arglists f))\n        meta-map (assoc meta-map\n                        :ns @vars/current-ns\n                        :arglists arglists)\n        fn-name (with-meta fn-name\n                  (cond-> meta-map\n                    docstring (assoc :doc docstring)\n                    macro? (assoc :macro true)))\n        f (assoc f\n                 :sci/macro macro?\n                 :sci.impl/fn-name fn-name)]\n    (mark-eval-call (list 'def fn-name f))))\n\n(defn expand-comment\n  \"The comment macro from clojure.core.\"\n  [_ctx & _body])\n\n(defn expand-loop\n  [ctx expr]\n  (let [bv (second expr)\n        arg-names (take-nth 2 bv)\n        init-vals (take-nth 2 (rest bv))\n        body (nnext expr)]\n    (analyze ctx (apply list `(fn ~(vec arg-names) ~@body)\n                        init-vals))))\n\n(defn expand-lazy-seq\n  [ctx expr]\n  (let [body (rest expr)]\n    (mark-eval-call\n     (list 'lazy-seq\n           (analyze ctx\n                    ;; expand-fn will take care of the analysis of the body\n                    (list 'fn [] (cons 'do body)))))))\n\n(defn expand-if\n  [ctx [_if & exprs :as expr]]\n  (case (count exprs)\n    (0 1) (throw-error-with-location \"Too few arguments to if\" expr)\n    (2 3) (mark-eval-call `(~'if ~@(analyze-children ctx exprs)))\n    (throw-error-with-location \"Too many arguments to if\" expr)))\n\n(defn expand-case\n  [ctx expr]\n  (let [v (analyze ctx (second expr))\n        clauses (nnext expr)\n        match-clauses (take-nth 2 clauses)\n        result-clauses (analyze-children ctx (take-nth 2 (rest clauses)))\n        default (when (odd? (count clauses))\n                  [:val (analyze ctx (last clauses))])\n        cases (interleave match-clauses result-clauses)\n        assoc-new (fn [m k v]\n                    (if-not (contains? m k)\n                      (assoc m k v)\n                      (throw-error-with-location (str \"Duplicate case test constant \" k)\n                                                 expr)))\n        case-map (loop [cases (seq cases)\n                        ret-map {}]\n                   (if cases\n                     (let [[k v & cases] cases]\n                       (if (list? k)\n                         (recur\n                          cases\n                          (reduce (fn [acc k]\n                                    (assoc-new acc k v))\n                                  ret-map\n                                  k))\n                         (recur\n                          cases\n                          (assoc-new ret-map k v))))\n                     ret-map))\n        ret (mark-eval-call (list 'case\n                                  {:case-map case-map\n                                   :case-val v\n                                   :case-default default}\n                                  default))]\n    (mark-eval-call ret)))\n\n(defn expand-try\n  [ctx [_try & body]]\n  (let [[body-exprs\n         catches\n         finally]\n        (loop [exprs #_[expr & exprs :as all-exprs] (seq body)\n               body-exprs []\n               catch-exprs []\n               finally-expr nil]\n          (if exprs\n            (let [expr (first exprs)\n                  exprs (next exprs)]\n              (cond (and (seq? expr) (= 'catch (first expr)))\n                    (recur exprs body-exprs (conj catch-exprs expr) finally-expr)\n                    (and (not exprs) (and (seq? expr) (= 'finally (first expr))))\n                    [body-exprs catch-exprs expr]\n                    :else\n                    ;; TODO: cannot add body expression when catch is not empty\n                    ;; TODO: can't have finally as non-last expression\n                    (recur exprs (conj body-exprs expr) catch-exprs finally-expr)))\n            [body-exprs catch-exprs finally-expr]))\n        body (analyze ctx (cons 'do body-exprs))\n        catches (mapv (fn [c]\n                        (let [[_ ex binding & body] c]\n                          (if-let [clazz (interop/resolve-class ctx ex)]\n                            {:class clazz\n                             :binding binding\n                             :body (analyze (assoc-in ctx [:bindings binding] nil)\n                                            (cons 'do body))}\n                            (throw-error-with-location (str \"Unable to resolve classname: \" ex) ex))))\n                      catches)\n        finally (when finally\n                  (analyze ctx (cons 'do (rest finally))))]\n    (with-meta\n      {:sci.impl/try\n       {:body body\n        :catches catches\n        :finally finally}}\n      {:sci.impl/op :try})))\n\n(defn expand-declare [ctx [_declare & names :as _expr]]\n  (swap! (:env ctx)\n         (fn [env]\n           (let [cnn (vars/current-ns-name)]\n             (update-in env [:namespaces cnn]\n                        (fn [current-ns]\n                          (reduce (fn [acc name]\n                                    (if (contains? acc name)\n                                      ;; declare does not override an existing\n                                      ;; var\n                                      acc\n                                      (assoc acc name\n                                             (doto (vars/->SciVar nil (symbol (str cnn)\n                                                                              (str name))\n                                                                  (assoc (meta name)\n                                                                         :name name\n                                                                         :ns @vars/current-ns\n                                                                         :file @vars/current-file))\n                                               (vars/unbind)))))\n                                  current-ns\n                                  names))))))\n  nil)\n\n(defn do-import [{:keys [:env] :as ctx} [_ & import-symbols-or-lists :as expr]]\n  (let [specs (map #(if (and (seq? %) (= 'quote (first %))) (second %) %)\n                   import-symbols-or-lists)]\n    (doseq [spec (reduce (fn [v spec]\n                           (if (symbol? spec)\n                             (conj v (name spec))\n                             (let [p (first spec) cs (rest spec)]\n                               (into v (map #(str p \".\" %) cs)))))\n                         [] specs)]\n      (let [fq-class-name (symbol spec)]\n        (when-not (interop/resolve-class ctx fq-class-name)\n          (throw-error-with-location (str \"Unable to resolve classname: \" fq-class-name) expr))\n        (let [last-dot (str/last-index-of spec \".\")\n              class-name (subs spec (inc last-dot) (count spec))\n              cnn (vars/current-ns-name)]\n          (swap! env assoc-in [:namespaces cnn :imports (symbol class-name)] fq-class-name))))))\n\n;;;; Interop\n\n(defn expand-dot [ctx [_dot instance-expr method-expr & args]]\n  (let [[method-expr & args] (if (seq? method-expr) method-expr\n                                 (cons method-expr args))\n        instance-expr (analyze ctx instance-expr)\n        instance-expr (utils/vary-meta*\n                       instance-expr\n                       (fn [m]\n                         (if-let [t (:tag m)]\n                           (let [clazz (or (interop/resolve-class ctx t)\n                                           (throw-error-with-location\n                                            (str \"Unable to resolve classname: \" t) t))]\n                             (assoc m :tag-class clazz))\n                           m)))\n        method-expr (name method-expr)\n        args (analyze-children ctx args)\n        res #?(:clj (if (class? instance-expr)\n                      `(~(with-meta [instance-expr method-expr]\n                           {:sci.impl/op :static-access}) ~@args)\n                      `(~'. ~instance-expr ~method-expr ~args))\n               :cljs `(~'. ~instance-expr ~method-expr ~args))]\n    (mark-eval-call res)))\n\n(defn expand-dot* [ctx [method-name obj & args]]\n  (expand-dot ctx (list '. obj (cons (symbol (subs (name method-name) 1)) args))))\n\n(defn expand-new [ctx [_new class-sym & args]]\n  (if-let [#?(:clj {:keys [:class] :as _opts}\n              :cljs {:keys [:constructor] :as _opts}) (interop/resolve-class-opts ctx class-sym)]\n    (let [args (analyze-children ctx args)] ;; analyze args!\n      (mark-eval-call (list 'new #?(:clj class :cljs constructor) args)))\n    (throw-error-with-location (str \"Unable to resolve classname: \" class-sym) class-sym)))\n\n(defn expand-constructor [ctx [constructor-sym & args]]\n  (let [;; TODO:\n        ;; here it strips the namespace, which is correct in the case of\n        ;; js/Error. but not in clj\n        constructor-name (name constructor-sym)\n        class-sym (with-meta (symbol (subs constructor-name 0\n                                           (dec (count constructor-name))))\n                    (meta constructor-sym))]\n    (expand-new ctx (with-meta (list* 'new class-sym args)\n                      (meta constructor-sym)))))\n\n;;;; End interop\n\n;;;; Namespaces\n\n(defn analyze-ns-form [ctx [_ns ns-name & exprs]]\n  (let [[docstring exprs]\n        (let [fexpr (first exprs)]\n          (if (string? fexpr)\n            [fexpr (next exprs)]\n            [nil exprs]))\n        ;; skip attr-map\n        [attr-map exprs]\n        (let [m (first exprs)]\n          (if (map? m)\n            [m (next exprs)]\n            [nil exprs]))\n        attr-map (if docstring\n                   (assoc attr-map :doc docstring)\n                   attr-map)]\n    (set-namespace! ctx ns-name attr-map)\n    (loop [exprs exprs\n           ret [#_(mark-eval-call (list 'in-ns ns-name)) ;; we don't have to do\n                ;; this twice I guess?\n                ]]\n      (if exprs\n        (let [[k & args] (first exprs)]\n          (case k\n            :require (recur (next exprs)\n                            (conj ret\n                                  (mark-eval-call\n                                   (list* 'require args))))\n            :import (do\n                      ;; imports are processed analysis time\n                      (do-import ctx `(~'import ~@args))\n                      (recur (next exprs) ret))\n            :refer-clojure (recur (next exprs)\n                                  (conj ret\n                                        (mark-eval-call\n                                         (list* 'refer 'clojure.core args))))\n            :gen-class ;; ignore\n            (recur (next exprs) ret)))\n        (mark-eval-call (list* 'do ret))))))\n\n;;;; End namespaces\n\n\n;;;; Vars\n\n(defn analyze-var [ctx [_ var-name]]\n  (resolve-symbol (assoc ctx :sci.impl/prevent-deref true) var-name))\n\n(defn analyze-set! [ctx [_ obj v]]\n  (let [obj (analyze ctx obj)\n        v (analyze ctx v)\n        obj (types/getVal obj)]\n    (mark-eval-call (list 'set! obj v))))\n\n;;;; End vars\n\n;;;; Macros\n\n(defn macro? [f]\n  (when-let [m (meta f)]\n    (:sci/macro m)))\n\n;;;; End macros\n\n(defn analyze-call [ctx expr]\n  (let [f (first expr)]\n    (if (symbol? f)\n      (let [;; in call position Clojure prioritizes special symbols over\n            ;; bindings\n            special-sym (get special-syms f)\n            _ (when special-sym (check-permission! ctx special-sym f))\n            f (or special-sym\n                  (resolve-symbol ctx f true))\n            f (if (and (vars/var? f)\n                       (or\n                        (vars/isMacro f)\n                        (-> f meta :sci.impl/built-in)))\n                @f f)]\n        (if (and (not (eval? f)) ;; the symbol is not a binding\n                 (or\n                  special-sym\n                  (contains? macros f)))\n          (case f\n            ;; we treat every subexpression of a top-level do as a separate\n            ;; analysis/interpretation unit so we hand this over to the\n            ;; interpreter again, which will invoke analysis + evaluation on\n            ;; every sub expression\n            do (mark-eval-call (cons 'do\n                                     (analyze-children ctx (rest expr))))\n            let (expand-let ctx expr)\n            (fn fn*) (expand-fn ctx expr false)\n            def (expand-def ctx expr)\n            ;; NOTE: defn / defmacro aren't implemented as normal macros yet\n            (defn defmacro) (let [ret (expand-defn ctx expr)]\n                              ret)\n            ;; TODO: implement as normal macro in namespaces.cljc\n            -> (expand-> ctx (rest expr))\n            ;; TODO: implement as normal macro in namespaces.cljc\n            as-> (expand-as-> ctx expr)\n            quote (do nil (second expr))\n            ;; TODO: implement as normal macro in namespaces.cljc\n            comment (expand-comment ctx expr)\n            loop (expand-loop ctx expr)\n            lazy-seq (expand-lazy-seq ctx expr)\n            for (let [res (expand-for ctx expr)]\n                  (if (:sci.impl/macroexpanding ctx)\n                    res\n                    (analyze ctx res)))\n            doseq (analyze ctx (expand-doseq ctx expr))\n            if (expand-if ctx expr)\n            case (expand-case ctx expr)\n            try (expand-try ctx expr)\n            declare (expand-declare ctx expr)\n            expand-dot* (expand-dot* ctx expr)\n            . (expand-dot ctx expr)\n            expand-constructor (expand-constructor ctx expr)\n            new (expand-new ctx expr)\n            import (do-import ctx expr)\n            ns (analyze-ns-form ctx expr)\n            var (analyze-var ctx expr)\n            set! (analyze-set! ctx expr)\n            ;; macroexpand-1 (macroexpand-1 ctx expr)\n            ;; macroexpand (macroexpand ctx expr)\n            ;; else:\n            (mark-eval-call (cons f (analyze-children ctx (rest expr)))))\n          (try\n            (if (macro? f)\n              (let [needs-ctx? (kw-identical? :needs-ctx\n                                              (:sci.impl/op (meta f)))\n                    v (if needs-ctx?\n                        (apply f expr\n                               (:bindings ctx)\n                               ctx\n                               (rest expr))\n                        (apply f expr\n                               (:bindings ctx) (rest expr)))\n                    expanded (if (:sci.impl/macroexpanding ctx)\n                               v\n                               (analyze ctx v))]\n                expanded)\n              (mark-eval-call (cons f (analyze-children ctx (rest expr)))))\n            (catch #?(:clj Exception :cljs js/Error) e\n              (rethrow-with-location-of-node ctx e expr)))))\n      (let [ret (mark-eval-call (analyze-children ctx expr))]\n        ret))))\n\n(defn analyze\n  [ctx expr]\n  ;; (prn \"ana\" expr)\n  (let [ret (cond (constant? expr) expr ;; constants do not carry metadata\n                  (symbol? expr) (let [v (resolve-symbol ctx expr false)]\n                                   (cond (constant? v) v\n                                         ;; (fn? v) (utils/vary-meta* v dissoc :sci.impl/op)\n                                         (vars/var? v) (if (:const (meta v))\n                                                         @v (types/->EvalVar v))\n                                         :else (merge-meta v (meta expr))))\n                  :else\n                  (merge-meta\n                   (cond\n                     (map? expr)\n                     (-> (zipmap (analyze-children ctx (keys expr))\n                                 (analyze-children ctx (vals expr)))\n                         mark-eval)\n                     (or (vector? expr) (set? expr))\n                     (-> (into (empty expr) (analyze-children ctx expr))\n                         mark-eval)\n                     (and (seq? expr) (seq expr))\n                     (analyze-call ctx expr)\n                     :else expr)\n                   (select-keys (meta expr)\n                                [:line :column :tag])))]\n    ;; (prn \"ana\" expr '-> ret 'm-> (meta ret))\n    ret))\n\n;;;; Scratch\n\n(comment\n  )\n"]}
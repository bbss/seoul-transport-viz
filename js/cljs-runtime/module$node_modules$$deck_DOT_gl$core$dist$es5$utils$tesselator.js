shadow$provide.module$node_modules$$deck_DOT_gl$core$dist$es5$utils$tesselator=function(global,require,module,exports){global=require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=void 0;var _classCallCheck2=global(require("module$node_modules$$babel$runtime$helpers$classCallCheck")),_createClass2=global(require("module$node_modules$$babel$runtime$helpers$createClass")),_iterableUtils=require("module$node_modules$$deck_DOT_gl$core$dist$es5$utils$iterable_utils"),
_typedArrayManager=global(require("module$node_modules$$deck_DOT_gl$core$dist$es5$utils$typed_array_manager")),_assert=global(require("module$node_modules$$deck_DOT_gl$core$dist$es5$utils$assert")),_core=require("module$node_modules$$luma_DOT_gl$core$dist$es5$index");require=function(){function Tesselator(){var opts=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};(0,_classCallCheck2["default"])(this,Tesselator);var _opts$attributes=opts.attributes;_opts$attributes=void 0===_opts$attributes?
{}:_opts$attributes;this.typedArrayManager=_typedArrayManager["default"];this.vertexStarts=this.indexStarts=null;this.instanceCount=this.vertexCount=0;this.attributes={};this._attributeDefs=_opts$attributes;this.opts=opts;this.updateGeometry(opts);Object.seal(this)}(0,_createClass2["default"])(Tesselator,[{key:"updateGeometry",value:function(opts){Object.assign(this.opts,opts);var _this$opts=this.opts,data=_this$opts.data;opts=_this$opts.buffers;var buffers=void 0===opts?{}:opts,getGeometry=_this$opts.getGeometry,
geometryBuffer=_this$opts.geometryBuffer,positionFormat=_this$opts.positionFormat;opts=_this$opts.dataChanged;_this$opts=_this$opts.normalize;_this$opts=void 0===_this$opts?!0:_this$opts;this.data=data;this.getGeometry=getGeometry;this.positionSize=geometryBuffer&&geometryBuffer.size||("XY"===positionFormat?2:3);this.buffers=buffers;this.normalize=_this$opts;geometryBuffer&&((0,_assert["default"])(data.startIndices,"binary data missing startIndices"),this.getGeometry=this.getGeometryFromBuffer(geometryBuffer),
_this$opts||(buffers.positions=geometryBuffer));this.geometryBuffer=buffers.positions;if(Array.isArray(opts)){data=!0;buffers=!1;getGeometry=void 0;try{for(var _iterator=opts[Symbol.iterator](),_step;!(data=(_step=_iterator.next()).done);data=!0)this._rebuildGeometry(_step.value)}catch(err){buffers=!0,getGeometry=err}finally{try{if(!data&&null!=_iterator["return"])_iterator["return"]()}finally{if(buffers)throw getGeometry;}}}else this._rebuildGeometry()}},{key:"updatePartialGeometry",value:function(_ref){this._rebuildGeometry({startRow:_ref.startRow,
endRow:_ref.endRow})}},{key:"normalizeGeometry",value:function(geometry){return geometry}},{key:"updateGeometryAttributes",value:function(geometry,startIndex,size){throw Error("Not implemented");}},{key:"getGeometrySize",value:function(geometry){throw Error("Not implemented");}},{key:"getGeometryFromBuffer",value:function(geometryBuffer){var value=geometryBuffer.value||geometryBuffer;(0,_assert["default"])(ArrayBuffer.isView(value),"cannot read geometries");return(0,_iterableUtils.getAccessorFromBuffer)(value,
{size:this.positionSize,offset:geometryBuffer.offset,stride:geometryBuffer.stride,startIndices:this.data.startIndices})}},{key:"_allocate",value:function(instanceCount,copy){var attributes=this.attributes,buffers=this.buffers,_attributeDefs=this._attributeDefs,typedArrayManager=this.typedArrayManager,name;for(name in _attributeDefs)if(name in buffers)typedArrayManager.release(attributes[name]),attributes[name]=null;else{var def=_attributeDefs[name];def.copy=copy;attributes[name]=typedArrayManager.allocate(attributes[name],
instanceCount,def)}}},{key:"_forEachGeometry",value:function(visitor,startRow,endRow){var data=this.data,getGeometry=this.getGeometry;endRow=(0,_iterableUtils.createIterable)(data,startRow,endRow);startRow=endRow.iterable;endRow=endRow.objectInfo;data=!0;var _didIteratorError2=!1,_iteratorError2=void 0;try{for(var _iterator2=startRow[Symbol.iterator](),_step2;!(data=(_step2=_iterator2.next()).done);data=!0){var object=_step2.value;endRow.index++;var geometry=getGeometry(object,endRow);visitor(geometry,
endRow.index)}}catch(err){_didIteratorError2=!0,_iteratorError2=err}finally{try{if(!data&&null!=_iterator2["return"])_iterator2["return"]()}finally{if(_didIteratorError2)throw _iteratorError2;}}}},{key:"_rebuildGeometry",value:function(dataRange){var _this=this;if(this.data&&this.getGeometry){var indexStarts=this.indexStarts,vertexStarts=this.vertexStarts,instanceCount=this.instanceCount,data=this.data,geometryBuffer=this.geometryBuffer,_ref2=dataRange||{},_ref2$startRow=_ref2.startRow;_ref2$startRow=
void 0===_ref2$startRow?0:_ref2$startRow;_ref2=_ref2.endRow;_ref2=void 0===_ref2?Infinity:_ref2;var normalizedData={};dataRange||(indexStarts=[0],vertexStarts=[0]);if(this.normalize||!geometryBuffer)this._forEachGeometry(function(geometry,dataIndex){geometry=_this.normalizeGeometry(geometry);normalizedData[dataIndex]=geometry;vertexStarts[dataIndex+1]=vertexStarts[dataIndex]+_this.getGeometrySize(geometry)},_ref2$startRow,_ref2),instanceCount=vertexStarts[vertexStarts.length-1];else if(geometryBuffer.buffer instanceof
_core.Buffer){var byteStride=geometryBuffer.stride||4*this.positionSize;vertexStarts=data.startIndices;instanceCount=vertexStarts[data.length]||geometryBuffer.buffer.byteLength/byteStride}else byteStride=geometryBuffer.value||geometryBuffer,geometryBuffer=geometryBuffer.stride/byteStride.BYTES_PER_ELEMENT||this.positionSize,vertexStarts=data.startIndices,instanceCount=vertexStarts[data.length]||byteStride.length/geometryBuffer;this._allocate(instanceCount,!!dataRange);this.indexStarts=indexStarts;
this.vertexStarts=vertexStarts;this.instanceCount=instanceCount;var context={};this._forEachGeometry(function(geometry,dataIndex){geometry=normalizedData[dataIndex]||geometry;context.vertexStart=vertexStarts[dataIndex];context.indexStart=indexStarts[dataIndex];context.geometrySize=(dataIndex<vertexStarts.length-1?vertexStarts[dataIndex+1]:instanceCount)-vertexStarts[dataIndex];context.geometryIndex=dataIndex;_this.updateGeometryAttributes(geometry,context)},_ref2$startRow,_ref2);this.vertexCount=
indexStarts[indexStarts.length-1]}}}]);return Tesselator}();exports["default"]=require}
//# sourceMappingURL=module$node_modules$$deck_DOT_gl$core$dist$es5$utils$tesselator.js.map

{
"version":3,
"file":"module$node_modules$$math_DOT_gl$polygon$dist$es5$cut_by_mercator_bounds.js",
"lineCount":10,
"mappings":"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",
"sources":["node_modules/@math_DOT_gl/polygon/dist/es5/cut-by-mercator-bounds.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$math_DOT_gl$polygon$dist$es5$cut_by_mercator_bounds\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cutPolylineByMercatorBounds = cutPolylineByMercatorBounds;\nexports.cutPolygonByMercatorBounds = cutPolygonByMercatorBounds;\n\nvar _cutByGrid = require(\"./cut-by-grid\");\n\nvar _utils = require(\"./utils\");\n\nvar DEFAULT_MAX_LATITUDE = 85.051129;\n\nfunction cutPolylineByMercatorBounds(positions) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$size = options.size,\n      size = _options$size === void 0 ? 2 : _options$size,\n      _options$startIndex = options.startIndex,\n      startIndex = _options$startIndex === void 0 ? 0 : _options$startIndex,\n      _options$endIndex = options.endIndex,\n      endIndex = _options$endIndex === void 0 ? positions.length : _options$endIndex,\n      _options$normalize = options.normalize,\n      normalize = _options$normalize === void 0 ? true : _options$normalize;\n  var newPositions = positions.slice(startIndex, endIndex);\n  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);\n  var parts = (0, _cutByGrid.cutPolylineByGrid)(newPositions, {\n    size: size,\n    broken: true,\n    gridResolution: 360,\n    gridOffset: [-180, -180]\n  });\n\n  if (normalize) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var part = _step.value;\n        shiftLongitudesIntoRange(part, size);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  return parts;\n}\n\nfunction cutPolygonByMercatorBounds(positions, holeIndices) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$size2 = options.size,\n      size = _options$size2 === void 0 ? 2 : _options$size2,\n      _options$normalize2 = options.normalize,\n      normalize = _options$normalize2 === void 0 ? true : _options$normalize2,\n      _options$edgeTypes = options.edgeTypes,\n      edgeTypes = _options$edgeTypes === void 0 ? false : _options$edgeTypes;\n  holeIndices = holeIndices || [];\n  var newPositions = [];\n  var newHoleIndices = [];\n  var srcStartIndex = 0;\n  var targetIndex = 0;\n\n  for (var ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {\n    var srcEndIndex = holeIndices[ringIndex] || positions.length;\n    var targetStartIndex = targetIndex;\n    var splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);\n\n    for (var i = splitIndex; i < srcEndIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    for (var _i = srcStartIndex; _i < splitIndex; _i++) {\n      newPositions[targetIndex++] = positions[_i];\n    }\n\n    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);\n    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options.maxLatitude);\n    srcStartIndex = srcEndIndex;\n    newHoleIndices[ringIndex] = targetIndex;\n  }\n\n  newHoleIndices.pop();\n  var parts = (0, _cutByGrid.cutPolygonByGrid)(newPositions, newHoleIndices, {\n    size: size,\n    gridResolution: 360,\n    gridOffset: [-180, -180],\n    edgeTypes: edgeTypes\n  });\n\n  if (normalize) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = parts[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var part = _step2.value;\n        shiftLongitudesIntoRange(part.positions, size);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n\n  return parts;\n}\n\nfunction findSplitIndex(positions, size, startIndex, endIndex) {\n  var maxLat = -1;\n  var pointIndex = -1;\n\n  for (var i = startIndex + 1; i < endIndex; i += size) {\n    var lat = Math.abs(positions[i]);\n\n    if (lat > maxLat) {\n      maxLat = lat;\n      pointIndex = i - 1;\n    }\n  }\n\n  return pointIndex;\n}\n\nfunction insertPoleVertices(positions, size, startIndex, endIndex) {\n  var maxLatitude = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_MAX_LATITUDE;\n  var firstLng = positions[startIndex];\n  var lastLng = positions[endIndex - size];\n\n  if (Math.abs(firstLng - lastLng) > 180) {\n    var p = (0, _utils.getPointAtIndex)(positions, 0, size, startIndex);\n    p[0] += Math.round((lastLng - firstLng) / 360) * 360;\n    (0, _utils.push)(positions, p);\n    p[1] = Math.sign(p[1]) * maxLatitude;\n    (0, _utils.push)(positions, p);\n    p[0] = firstLng;\n    (0, _utils.push)(positions, p);\n  }\n}\n\nfunction wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {\n  var prevLng = positions[0];\n  var lng;\n\n  for (var i = startIndex; i < endIndex; i += size) {\n    lng = positions[i];\n    var delta = lng - prevLng;\n\n    if (delta > 180 || delta < -180) {\n      lng -= Math.round(delta / 360) * 360;\n    }\n\n    positions[i] = prevLng = lng;\n  }\n}\n\nfunction shiftLongitudesIntoRange(positions, size) {\n  var refLng;\n  var pointCount = positions.length / size;\n\n  for (var i = 0; i < pointCount; i++) {\n    refLng = positions[i * size];\n\n    if ((refLng + 180) % 360 !== 0) {\n      break;\n    }\n  }\n\n  var delta = -Math.round(refLng / 360) * 360;\n\n  if (delta === 0) {\n    return;\n  }\n\n  for (var _i2 = 0; _i2 < pointCount; _i2++) {\n    positions[_i2 * size] += delta;\n  }\n}\n//# sourceMappingURL=cut-by-mercator-bounds.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","insertPoleVertices","positions","size","startIndex","endIndex","maxLatitude","arguments","length","undefined","DEFAULT_MAX_LATITUDE","firstLng","lastLng","Math","abs","p","_utils","getPointAtIndex","round","push","sign","wrapLongitudesForShortestPath","prevLng","i","lng","delta","shiftLongitudesIntoRange","refLng","pointCount","_i2","Object","defineProperty","value","cutPolylineByMercatorBounds","options","_options$size","_options$startIndex","_options$endIndex","_options$normalize","normalize","newPositions","slice","parts","_cutByGrid","cutPolylineByGrid","broken","gridResolution","gridOffset","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","Symbol","iterator","_step","done","next","err","cutPolygonByMercatorBounds","holeIndices","_options$size2","_options$normalize2","_options$edgeTypes","edgeTypes","newHoleIndices","srcStartIndex","targetIndex","ringIndex","srcEndIndex","targetStartIndex","splitIndex","pointIndex","maxLat","lat","_i","pop","cutPolygonByGrid","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2"]
}

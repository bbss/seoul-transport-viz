shadow$provide.module$node_modules$$deck_DOT_gl$layers$dist$es5$arc_layer$arc_layer_vertex_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=void 0;exports["default"]="#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\nattribute float instanceHeights;\nattribute float instanceTilts;\n\nuniform bool greatCircle;\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\n\n  float deltaZ \x3d targetZ - sourceZ;\n  float dh \x3d distance * instanceHeights;\n  float unitZ \x3d dh \x3d\x3d 0.0 ? 0.0 : deltaZ / dh;\n  float p2 \x3d unitZ * unitZ + 1.0;\n  float dir \x3d step(deltaZ, 0.0);\n  float z0 \x3d mix(sourceZ, targetZ, dir);\n  float r \x3d mix(ratio, 1.0 - ratio, dir);\n  return sqrt(r * (p2 - r)) * dh + z0;\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace \x3d normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace \x3d vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\n  float distance \x3d length(source.xy - target.xy);\n  float z \x3d paraboloid(distance, source.z, target.z, segmentRatio);\n\n  float tiltAngle \x3d radians(instanceTilts);\n  vec2 tiltDirection \x3d normalize(target.xy - source.xy);\n  vec2 tilt \x3d vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\n\n  return vec3(\n    mix(source.xy, target.xy, segmentRatio) + tilt,\n    z * cos(tiltAngle)\n  );\n}\nfloat getAngularDist (vec2 source, vec2 target) {\n  vec2 sourceRadians \x3d radians(source);\n  vec2 targetRadians \x3d radians(target);\n  vec2 sin_half_delta \x3d sin((sourceRadians - targetRadians) / 2.0);\n  vec2 shd_sq \x3d sin_half_delta * sin_half_delta;\n\n  float a \x3d shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\n  return 2.0 * asin(sqrt(a));\n}\n\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\n  vec2 lngLat;\n  if(abs(angularDist - PI) \x3c 0.001) {\n    lngLat \x3d (1.0 - t) * source.xy + t * target.xy;\n  } else {\n    float a \x3d sin((1.0 - t) * angularDist);\n    float b \x3d sin(t * angularDist);\n    vec3 p \x3d source3D.yxz * a + target3D.yxz * b;\n    lngLat \x3d degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n  }\n\n  float z \x3d paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\n\n  return vec3(lngLat, z);\n}\n\nvoid main(void) {\n  geometry.worldPosition \x3d instanceSourcePositions;\n  geometry.worldPositionAlt \x3d instanceTargetPositions;\n\n  float segmentIndex \x3d positions.x;\n  float segmentRatio \x3d getSegmentRatio(segmentIndex);\n  float indexDir \x3d mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  isValid \x3d 1.0;\n\n  uv \x3d vec2(segmentRatio, positions.y);\n  geometry.uv \x3d uv;\n  geometry.pickingColor \x3d instancePickingColors;\n\n  vec4 curr;\n  vec4 next;\n\n  if ((greatCircle || project_uProjectionMode \x3d\x3d PROJECTION_MODE_GLOBE) \x26\x26 project_uCoordinateSystem \x3d\x3d COORDINATE_SYSTEM_LNGLAT) {\n    vec3 source \x3d project_globe_(vec3(instanceSourcePositions.xy, 0.0));\n    vec3 target \x3d project_globe_(vec3(instanceTargetPositions.xy, 0.0));\n    float angularDist \x3d getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\n  \n    float prevSegmentRatio \x3d getSegmentRatio(max(0.0, segmentIndex - 1.0));\n    float nextSegmentRatio \x3d getSegmentRatio(min(numSegments, segmentIndex + 1.0));\n\n    vec3 prevPos \x3d interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\n    vec3 currPos \x3d interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\n    vec3 nextPos \x3d interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\n\n    if (abs(currPos.x - prevPos.x) \x3e 180.0) {\n      indexDir \x3d -1.0;\n      isValid \x3d 0.0;\n    } else if (abs(currPos.x - nextPos.x) \x3e 180.0) {\n      indexDir \x3d 1.0;\n      isValid \x3d 0.0;\n    }\n    nextPos \x3d indexDir \x3c 0.0 ? prevPos : nextPos;\n    nextSegmentRatio \x3d indexDir \x3c 0.0 ? prevSegmentRatio : nextSegmentRatio;\n\n    if (isValid \x3d\x3d 0.0) {\n      nextPos.x +\x3d nextPos.x \x3e 0.0 ? -360.0 : 360.0;\n      float t \x3d ((currPos.x \x3e 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\n      currPos \x3d mix(currPos, nextPos, t);\n      segmentRatio \x3d mix(segmentRatio, nextSegmentRatio, t);\n    }\n\n    vec3 currPos64Low \x3d mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\n    vec3 nextPos64Low \x3d mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\n  \n    curr \x3d project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\n    next \x3d project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n  \n  } else {\n    vec3 source \x3d project_position(instanceSourcePositions, instanceSourcePositions64Low);\n    vec3 target \x3d project_position(instanceTargetPositions, instanceTargetPositions64Low);\n\n    float nextSegmentRatio \x3d getSegmentRatio(segmentIndex + indexDir);\n    vec3 currPos \x3d interpolateFlat(source, target, segmentRatio);\n    vec3 nextPos \x3d interpolateFlat(source, target, nextSegmentRatio);\n    curr \x3d project_common_position_to_clipspace(vec4(currPos, 1.0));\n    next \x3d project_common_position_to_clipspace(vec4(nextPos, 1.0));\n    geometry.position \x3d vec4(currPos, 1.0);\n  }\n  float widthPixels \x3d clamp(\n    project_size_to_pixel(instanceWidths * widthScale),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset \x3d vec3(\n    getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  gl_Position \x3d curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vec4 color \x3d mix(instanceSourceColors, instanceTargetColors, segmentRatio);\n  vColor \x3d vec4(color.rgb, color.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n"}
//# sourceMappingURL=module$node_modules$$deck_DOT_gl$layers$dist$es5$arc_layer$arc_layer_vertex_glsl.js.map

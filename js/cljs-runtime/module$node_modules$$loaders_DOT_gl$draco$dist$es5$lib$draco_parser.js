shadow$provide.module$node_modules$$loaders_DOT_gl$draco$dist$es5$lib$draco_parser=function(global,require,module,exports){global=require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0});exports["default"]=void 0;var _classCallCheck2=global(require("module$node_modules$$babel$runtime$helpers$classCallCheck")),_createClass2=global(require("module$node_modules$$babel$runtime$helpers$createClass")),_loaderUtils=require("module$node_modules$$loaders_DOT_gl$loader_utils$dist$es5$index"),
DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP={POSITION:"POSITION",NORMAL:"NORMAL",COLOR:"COLOR_0",TEX_COORD:"TEXCOORD_0"},DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP={1:Int8Array,2:Uint8Array,3:Int16Array,4:Uint16Array,5:Int32Array,6:Uint32Array,9:Float32Array};require=function(){function DracoParser(draco){(0,_classCallCheck2["default"])(this,DracoParser);this.draco=draco;this.drawMode="TRIANGLE"}(0,_createClass2["default"])(DracoParser,[{key:"destroy",value:function(){}},{key:"destroyGeometry",value:function(dracoGeometry){dracoGeometry&&
this.draco.destroy(dracoGeometry.dracoGeometry)}},{key:"parseSync",value:function(arrayBuffer,options){options=new this.draco.DecoderBuffer;options.Init(new Int8Array(arrayBuffer),arrayBuffer.byteLength);arrayBuffer=new this.draco.Decoder;var data={};try{var geometryType=arrayBuffer.GetEncodedGeometryType(options);switch(geometryType){case this.draco.TRIANGULAR_MESH:var dracoGeometry=new this.draco.Mesh;var dracoStatus=arrayBuffer.DecodeBufferToMesh(options,dracoGeometry);var header={type:0,faceCount:dracoGeometry.num_faces(),
attributeCount:dracoGeometry.num_attributes(),vertexCount:dracoGeometry.num_points()};break;case this.draco.POINT_CLOUD:dracoGeometry=new this.draco.PointCloud;dracoStatus=arrayBuffer.DecodeBufferToPointCloud(options,dracoGeometry);header={type:1,attributeCount:dracoGeometry.num_attributes(),vertexCount:dracoGeometry.num_points()};break;default:throw Error("Unknown DRACO geometry type.");}if(!dracoStatus.ok()||!dracoGeometry.ptr){var message="DRACO decompression failed: ".concat(dracoStatus.error_msg());
dracoGeometry&&this.draco.destroy(dracoGeometry);throw Error(message);}data.loaderData={header:header};this.extractDRACOGeometry(arrayBuffer,dracoGeometry,geometryType,data);data.header={vertexCount:header.vertexCount,boundingBox:(0,_loaderUtils.getMeshBoundingBox)(data.attributes)}}finally{this.draco.destroy(arrayBuffer),this.draco.destroy(options)}return data}},{key:"extractDRACOGeometry",value:function(decoder,dracoGeometry,geometryType,geometry){var attributes=this.getAttributes(decoder,dracoGeometry),
positionAttribute=attributes.POSITION;if(!positionAttribute)throw Error("DRACO decompressor: No position attribute found.");this.getPositionAttributeMetadata(positionAttribute);geometryType===this.draco.TRIANGULAR_MESH?(attributes.indices="TRIANGLE_STRIP"===this.drawMode?this.getMeshStripIndices(decoder,dracoGeometry):this.getMeshFaceIndices(decoder,dracoGeometry),geometry.mode="TRIANGLE_STRIP"===this.drawMode?5:4):geometry.mode=0;attributes.indices&&(geometry.indices={value:attributes.indices,size:1},
delete attributes.indices);geometry.attributes=attributes;return geometry}},{key:"getPositionAttributeMetadata",value:function(positionAttribute){this.metadata=this.metadata||{};this.metadata.attributes=this.metadata.attributes||{};var posTransform=new this.draco.AttributeQuantizationTransform;if(posTransform.InitFromAttribute(positionAttribute))for(this.metadata.attributes.position.isQuantized=!0,this.metadata.attributes.position.maxRange=posTransform.range(),this.metadata.attributes.position.numQuantizationBits=
posTransform.quantization_bits(),this.metadata.attributes.position.minValues=new Float32Array(3),positionAttribute=0;3>positionAttribute;++positionAttribute)this.metadata.attributes.position.minValues[positionAttribute]=posTransform.min_value(positionAttribute);this.draco.destroy(posTransform)}},{key:"getAttributes",value:function(decoder,dracoGeometry){var attributes={},numPoints=dracoGeometry.num_points(),attributeName;for(attributeName in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP){var attributeId=decoder.GetAttributeId(dracoGeometry,
this.draco[attributeName]);-1!==attributeId&&(attributeId=decoder.GetAttribute(dracoGeometry,attributeId),attributeId=this.getAttributeTypedArray(decoder,dracoGeometry,attributeId,attributeName).typedArray,attributes[DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[attributeName]]={value:attributeId,size:attributeId.length/numPoints})}return attributes}},{key:"getMeshFaceIndices",value:function(decoder,dracoGeometry){for(var numFaces=dracoGeometry.num_faces(),indices=new Uint32Array(3*numFaces),dracoArray=new this.draco.DracoInt32Array,
i=0;i<numFaces;++i){decoder.GetFaceFromMesh(dracoGeometry,i,dracoArray);var index=3*i;indices[index]=dracoArray.GetValue(0);indices[index+1]=dracoArray.GetValue(1);indices[index+2]=dracoArray.GetValue(2)}this.draco.destroy(dracoArray);return indices}},{key:"getMeshStripIndices",value:function(decoder,dracoGeometry){var dracoArray=new this.draco.DracoInt32Array;decoder.GetTriangleStripsFromMesh(dracoGeometry,dracoArray);decoder=new Uint32Array(dracoArray.size());for(dracoGeometry=0;dracoGeometry<dracoArray.size();++dracoGeometry)decoder[dracoGeometry]=
dracoArray.GetValue(dracoGeometry);this.draco.destroy(dracoArray);return decoder}},{key:"getAttributeTypedArray",value:function(decoder,dracoGeometry,dracoAttribute,attributeName){if(0===dracoAttribute.ptr)throw attributeName="DRACO decode bad attribute ".concat(attributeName),Error(attributeName);var attributeType=DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()];attributeName=dracoAttribute.num_components();var numValues=dracoGeometry.num_points()*attributeName;switch(attributeType){case Float32Array:attributeType=
new this.draco.DracoFloat32Array;decoder.GetAttributeFloatForAllPoints(dracoGeometry,dracoAttribute,attributeType);decoder=new Float32Array(numValues);break;case Int8Array:attributeType=new this.draco.DracoInt8Array;decoder.GetAttributeInt8ForAllPoints(dracoGeometry,dracoAttribute,attributeType);decoder=new Int8Array(numValues);break;case Int16Array:attributeType=new this.draco.DracoInt16Array;decoder.GetAttributeInt16ForAllPoints(dracoGeometry,dracoAttribute,attributeType);decoder=new Int16Array(numValues);
break;case Int32Array:attributeType=new this.draco.DracoInt32Array;decoder.GetAttributeInt32ForAllPoints(dracoGeometry,dracoAttribute,attributeType);decoder=new Int32Array(numValues);break;case Uint8Array:attributeType=new this.draco.DracoUInt8Array;decoder.GetAttributeUInt8ForAllPoints(dracoGeometry,dracoAttribute,attributeType);decoder=new Uint8Array(numValues);break;case Uint16Array:attributeType=new this.draco.DracoUInt16Array;decoder.GetAttributeUInt16ForAllPoints(dracoGeometry,dracoAttribute,
attributeType);decoder=new Uint16Array(numValues);break;case Uint32Array:attributeType=new this.draco.DracoUInt32Array;decoder.GetAttributeUInt32ForAllPoints(dracoGeometry,dracoAttribute,attributeType);decoder=new Uint32Array(numValues);break;default:throw Error("DRACO decoder: unexpected attribute type.");}for(dracoGeometry=0;dracoGeometry<numValues;dracoGeometry++)decoder[dracoGeometry]=attributeType.GetValue(dracoGeometry);this.draco.destroy(attributeType);return{typedArray:decoder,components:attributeName}}},
{key:"decode",value:function(arrayBuffer,options){return this.parseSync(arrayBuffer,options)}}]);return DracoParser}();exports["default"]=require}
//# sourceMappingURL=module$node_modules$$loaders_DOT_gl$draco$dist$es5$lib$draco_parser.js.map
